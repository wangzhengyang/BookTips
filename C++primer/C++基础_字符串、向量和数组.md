[toc]

# 命名空间的`using`声明
头文件不应包含`using`声明

# 标准库类型`string`
```c++
#include <string>
using std::string
```
## 定义和初始化`string`对象
|定义和初始化| 描述|
|-|-|
|string s1|默认初始化，s1是一个空串|
|string s2(s1)|s2是s1的副本|
|string s2 = s1|等价于s2(s1)，s2是s1的副本|
|string s3("value")|s3是字面值"value"的副本，除了字面值最后的那个空字符外|
|string s3 = "value"|等价于s3("value")，s3是字面值"value"的副本|
|string s4(n, 'c')|把s4初始化为由连续n个字符c组成的串|
## `string`对象上的操作
|操作|描述|
|-|-|
|os<<s|将s写到输出流os当中，返回os|
|is>>s|从is中读取字符串赋给s，字符串以空白分隔，返回is|
|getline(is, s)|从is中读取一行赋给s，返回is|
|s.empty()|s为空返回true，否则返回false|
|s.size()|返回s中字符的个数|
|s[n]|返回s中第n个字符的引用，位置n从0计起|
|s1+s2|返回s1和s2连接后的结果|
|s1=s2|用s2的副本代替s1中原来的字符|
|s1==s2 s1!=s2|如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感|
|<,<=,>,>=|利用字符在字典中的顺序进行比较，且对字母的大小写敏感|
## `string::size_type`类型
`string`类型及其他大多数标准库类型都定义了几种配套的类型，`string::size_type`是一个无符号类型的值，而且能足够存下任何`string`对象的大小
## 处理`string`对象中的字符
```c++
#include <cctype>
```
|操作|描述|
|-|-|
|isalnum(c)|当c是字母或数字时为真|
|isalpha(c)|当c是字母时为真|
|iscntrl(c)|当c是控制字符时为真|
|isdigit(c)|当c是数字时为真|
|isgraph(c)|当c不是空格但可以打印时为真|
|islower(c)|当c是小写字母时为真|
|isprint(c)|当c是可打印字母时为真(即c是空格或c具有可视形式)|
|ispunct(c)|当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)|
|isspace(c)|当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)|
|isupper(c)|当c是大写字母时为真|
|tolower(c)|如果c是大写字母，输出对应的小写字母，否则原样输出c|
|toupper(c)|如果c是小写字母，输出对应的大写字母，否则原样输出c|

## 范围`for`语句
```c++
for (declaration : expression)
    statement
```

# 标准库类型`vector`
```c++
#include <vector>
using std::vector
```
## 定义和初始化`vector`对象
|定义|描述|
|-|-|
|vector<T> v1|v1是一个空vector，它潜在的元素是T类型，执行默认初始化|
|vector<T> v2(v1)|v2中包含有v1所有元素的副本|
|vector<T> v2 = v1|等价于v2(v1)，v2中包含有v1所有元素的副本|
|vector<T> v3(n, val)|v3包含了n个重复的元素，每个元素的值都是val|
|vector<T> v4(n)|v4包含了n个重复地执行了值初始化的对象|
|vector<T> v5{a,b,c...}|v5包含了初始值个数的元素，每个元素被赋予相应的初始值|
|vector<T> v5={a,b,c...}|等价于v5{a,b,c...}|
如果用的是圆括号，可以说提供的值是用来构造`vector`对象的，如果用的是花括号，可以表述成用列表初始化该`vector`对象，也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式
## 向`vector`对象中添加元素
`push_back`添加元素
## 其他`vector`操作
|操作|描述|
|-|-|
|v.empty()|如果v不含有任何元素，返回true；否则返回false|
|v.size()|返回v中元素的个数|
|v.push_back(t)|向v的尾端添加一个值为t的元素|
|v[n]|返回v中第n个位置上元素的引用|
|v1 = v2|用v2中元素的拷贝替换v1中的元素|
|v1 = {a,b,c...}|用列表中元素的拷贝替换v1中的元素|
|v1 == v2 v1 != v2|v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同|
|<,<=,>,=>|以字典顺序进行比较|

# 迭代器
## 使用迭代器
`begin`成员负责返回指向第一个元素(或第一个字符)的迭代器
`end`成员则负责返回指向容器(或`string`对象)"尾元素的下一位置"的迭代器
## 迭代器运算符
|操作|描述|
|-|-|
|*iter|返回迭代器iter所指元素的引用|
|iter->mem|解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem|
|++iter|令iter指示容器中的下一个元素|
|--iter|令iter指示容器中的上一个元素|
|iter1 == iter2 iter1 != iter2|判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等；反之，不相等|
## 迭代器类型
`const_iterator`对象能读取但不能修改；`iterator`对象可读可写
如果对象是常量，只能使用`const_iterator`；如果对象不是常量，既可以使用`iterator`也能使用`const_iterator`
`begin`和`end`返回的具体类型由对象是否是常量决定，如果对象是常量，`begin`和`end`返回`const_iterator`；如果对象不是常量，返回`iterator`
## 某些对`vector`对象的操作会使迭代器失效
凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素
## 迭代器运算
|操作|描述|
|-|-|
|iter + n|迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素，结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一个位置|
|iter - n|迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素，结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置|
|iter1 += n|迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1|
|iter1 -= n|迭代器减法的复合赋值语句，将iter1减n的结果赋给iter1|
|iter1 - iter2|两个迭代器相减的结果是它们之前的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器，参与运算的两个迭代器必须指向的同一个容器中的元素或者尾元素的下一位置|
|>,>=,<,<=|迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者，参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置|

# 数组
如果不清楚元素的确切个数，使用`vector`
## 访问数组元素
使用数组下标，通常定义为`size_t`类型，是一种无符号类型，它被设计得足够大以便能表示内存中任意对象的大小，在`cstddef`文件定义了该类型
## 标准库函数`begin`和`end`
`begin`函数返回指向数组首元素的指针，`end`函数返回指向数组尾元素下一位置的指针，定义在`iterator`头文件
`ptrdiff_t`是一种带符号的类型，定义在`cstddef`头文件中，表示两个指针相减得到的距离
## C风格字符串
`cstring`头文件
|操作|描述|
|-|-|
|strlen(p)|返回p的长度，空字符不计算在内|
|strcmp(p1, p2)|比较p1和p2的相等性，如果p1==p2，返回0；如果p1>p2，返回一个正值；如果p1<p2，返回一个负值|
|strcat(p1, p2)|将p2附加到p1之后，返回p1|
|strcpy(p1, p2)|将p2拷贝给p1，返回p1|
对大多数应用来说，使用标准库`string`要比使用C风格字符串更安全、更高效
## 与旧代码的接口
## 混用`string`对象和C风格字符串
允许使用字符串字面值来初始化`string`对象
```c++
string s("hello world");
```
`string`提供一个名为`c_str`的成员函数返回一个C风格的字符串，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，结果指针的类型是`const char*`，从而确保不会改变字符数组的内容
无法保证`c_str`函数返回的数组一直有效，如果后续的操作改变了s的值就可能让之前返回的数组失去效用，所以最好将该数组重新拷贝一份
## 使用数组初始化`vector`对象
```c++
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
vector<int> SubVec(int_arr + 1, int_arr + 4);
```
c++程序应当尽量使用`vector`和迭代器，避免使用内置数组和指针，应该尽量使用`string`，避免使用C风格的基于数组的字符串

# 多维数组









