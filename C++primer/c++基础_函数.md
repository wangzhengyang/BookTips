[toc]

# 局部静态变量
**局部静态变量**(local static object)在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响

# 参数传递
## 传值参数
当初始化一个非引用类型的变量时，初始值被拷贝给变量，此时，对变量的改动不会影响初始值
### 指针形参
当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后，两个指针时不同的指针，因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值
## 传引用参数
通过使用引用形参，允许函数改变一个或多个实参的值
### 使用引用避免拷贝
拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型(包括IO类型在内)根本就不支持拷贝操作，当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象

如果函数无须改变引用形参的值，最好将其声明为常量引用

### 使用引用形参返回额外信息
一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效途径

## const形参和实参
当用实参初始化形参时会忽略掉顶层cosnt

## 数组形参
数组的两个特殊性质分别是：不允许拷贝数组以及使用数组时(通常)会将其转换成指针

因为不能拷贝数组，所以无法以值传递的方式使用数组参数，因为数组会被转换成指针，当为函数传递一个数组时，实际上传递的是指向数组首元素的指针

### 使用标记指定数组长度
第一种方法是要求数组本身包含一个结束标记，C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符，函数在处理C风格字符串时遇到空字符停止

### 使用标准库规范
第二种方式是传递指向数组首元素和尾后元素的指针

### 显示传递一个表示数组大小的形参
第三种方法是专门定义一个表示数组大小的形参

### 数组形参和const
当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针，只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针

### 数组引用形参
将形参定义成数组的引用，引用形参绑定到对应的实参上

## 含有可变形参的函数
### `initializer_list`形参
定义在`initializer_list`头文件中
|操作|描述|
|-|-|
|initializer_list<T> lst;|默认初始化；T类型元素的空列表|
|initializer_list<T> lst{a,b,c...};|lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const|
|lst2(lst) lst2=lst|拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素|
|lst.size()|列表中的元素数量|
|lst.begin()|返回指向lst中的首元素的指针|
|lst.end()|返回指向lst中尾元素下一位置的指针|

# 返回类型和return语句
## 有返回值函数
1. 将返回值拷贝到调用点，会创建一个变量的副本或者一个未命名的临时对象
2. 函数返回引用，不会真正拷贝对象

### 不要返回局部变量的引用或指针
函数完成后，所占用的存储空间随之被释放，因此函数终止意味着局部变量的引用将指向不再有效的内存区域

### 引用返回左值
调用一个返回引用的函数得到左值，其他返回类型得到右值

## 返回数组指针
### 使用尾置返回类型
在形参列表后面并以一个`->`符号开头，为了表示函数真正的返回类型跟在形参列表之后，在本应该出现返回类型的地方放置一个`auto`
```c++
auto func(int i) -> int (*)[10]
```
### 使用`decltype`
如果知道函数返回的指针将指向哪个数组，就可以使用`decltype`关键字声明返回类型

# 函数重载
同一作用域内的几个函数名字相同但形参列表不同，称之为**重载函数**(overloaded)
### 定义重载函数
对于重载的函数，应该在形参数量或形参类型上有所不同，不允许两个函数除了返回类型外其他所有的要素都相同
### 重载和const形参
顶层const不影响传入函数的对象，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来

如果形参是某种类型的指针或引用，则通过区分其指向的是常量还是非常量对象可以实现函数重载，此时的const是底层的
### const_cast和重载
const_cast在重载函数的情景有用
```c++
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```
### 调用重载函数
1. 编译器找到一个与实参**最佳匹配**(best match)的函数，并生成调用该函数的代码
2. 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配**(no match)的错误信息
3. 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时将发生错误，称为**二义性调用**(ambiguous call)

# 特殊用途语言特性
## 默认实参
默认实参作为形参的初始值出现在形参列表中，可以为一个或多个形参定义默认值，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值

## 内联函数和constexpr函数
### 内联函数可避免函数调用的开销
将函数指定为**内联函数**(inline)，通常就是将它在每个调用点上"内联地"展开，从而消除函数调用的开销
### constexpr函数
**constexpr函数**是指能用于常量表达式的函数，函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句
### 把内联函数和constexpr函数放在头文件
内联函数和constexpr函数通常定义在头文件中

## 调试帮助
### assert预处理宏
定义在`cassert`头文件
```
assert(expr)
```
首先对expr求值，如果表达式为假(即0)，`assert`输出信息并终止程序的执行，如果表达式为真(即非0)，`assert`什么也不做
### `NDEBUG`预处理变量
`assert`的行为依赖于一个名为`NDEBUG`的预处理变量的状态，如果定义了`NDEBUG`，则`assert`什么也不做，默认情况下没有定义`NDEBUG`，此时`assert`将执行运行时检查

使用`NDEBUG`编写自己的条件调试代码
```
#ifndef NDEBUG
#endif
```
`__func__`：输出当前调试的函数的名字
`__FILE__`：存放文件名的字符串字面值
`__LINE__`：存放当前行号的整型字面值
`__TIME__`：存放文件编译时间的字符串字面值
`__DATE__`：存放文件编译日期的字符串字面值







