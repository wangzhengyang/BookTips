[toc]

一个类通过定义五种特殊的成员函数来控制对象拷贝、移动、赋值和销毁操作：**拷贝构造函数**(copy constructor)、**拷贝赋值运算符**(copy_assignment operator)、**移动构造函数**(move constructor)、**移动赋值运算符**(move-assignment operator)和**析构函数**(destructor)

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作

# 拷贝、赋值与销毁
## 拷贝构造函数
拷贝构造函数的第一参数必须是一个引用类型，此参数总是一个`const`的引用
拷贝构造函数通常不应该是`explicit`的

即使定义了其他构造函数，编译器也会合成一个拷贝构造函数

对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝

拷贝初始化不仅在用`=`定义变量时会发生，在下列情况下也会发生
1. 将一个对象作为实参传递给一个非引用类型的形参
2. 从一个返回类型为非引用类型的函数返回一个对象
3. 用花括号列表初始化一个数组中的元素或一个聚合类的成员

## 拷贝赋值运算符
赋值运算符就是一个名为`operator=`的函数

赋值运算符通常应该返回一个指向其左侧运算对象的引用

如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**(synthesized copy-assignment operator)

## 析构函数
释放对象使用的资源，并销毁对象的非static数据成员

析构函数不接受参数，因此它不能被重载

在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化，在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁

隐式销毁一个内置指针类型的成员不会`delete`它所指的对象

**与普通指针不同，智能指针是类类型，所以具有析构函数，因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁**

一个对象被销毁，自动调用其析构函数的情况：
1. 变量在离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器(无论是标准库容器还是数组)被销毁时，其元素被销毁
4. 对于动态分配的对象，当对指向它的指针应用`delete`运算符时被销毁
5. 对于临时对象，当创建它的完整表达式结束时被销毁

由于析构函数自动运行，程序可以按需要分配资源，而(通常)无须担心何时释放这些资源

**当指向一个对象的引用或指针离开作用域时，析构函数不会执行**

当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**(synthesized destructor)，类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁，如果不是这种情况，合成析构函数的函数体就为空

在(空)析构函数体执行完毕后，成员会被自动销毁

析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的

## 三/五法则
1. 需要析构函数的类也需要拷贝和赋值操作

如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数

2. 需要拷贝操作的类也需要赋值操作，反之亦然

## 使用`=default`
将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本

在类内使用`=default`修饰成员的声明时，合成的函数将隐式声明为内联的

只能对具有合成版本的成员函数使用`=default`(即，默认构造函数或拷贝控制成员或析构函数)

## 阻止拷贝
在函数的参数列表后面加上`=delete`来指出希望将它定义为删除的

于`=default`不同，`=delete`必须出现在函数第一次声明的时候

与`=default`另一个不同的是，可以对任何函数指定`=delete`

不能删除析构函数，如果析构函数被删除，就无法销毁此类型的对象，对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针

以下情况，编译器将这些合成的成员定义为删除的函数：
1. 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
2. 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的，如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的
3. 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个`const`的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
4. 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个`const`成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的

本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的

希望阻止拷贝的类应该使用`=delete`来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为`private`的

# 拷贝控制和资源管理
## 定义行为像值的类
编写赋值运算符时，需要：
1. 如果将一个对象赋予它自身，赋值运算符必须能正确工作
2. 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中，当拷贝完成后，销毁左侧运算对象的现有成员是安全的，一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了

对于赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作，一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象

## 定义行为像指针的类
