[toc]

模板是C++中泛型编程的基础，一个模板就是一个创建类或函数的蓝图或者说公式

# 定义模板
## 函数模板
以关键字`template`开始，后跟一个**模板参数列表**，这是一个逗号分隔的一个或多个**模板参数**的列表，用小于号(<)和大于号(>)包围起来

在模板定义中，模板参数列表不能为空

### 实例化函数模板
当调用一个函数模板时，编译器(通常)用函数实参来推断模板实参

编译器用推断出的模板参数来为我们**实例化**一个特定版本的函数，当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新实例

### 模板类型参数
模板**类型参数**，可以将它看作类型说明符，就像内置类型或类类型说明符一样使用，特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换

类型参数前必须使用关键字`class`或`typename`，在模板参数列表中，这两个关键字的含义相同，可以互换使用

### 非类型模板参数
非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字`class`或`typename`来指定非类型参数

非类型模板参数的模板实参必须是常量表达式

### 编写类型无关的代码
编写泛型代码的两个重要原则：
1. 模板中的函数参数是`const`的引用
2. 函数体中的条件判断仅使用简单运算

通过将函数参数设定为`const`的引用，保证了函数可以用于不能拷贝的类型

模板程序应该尽量减少对实参类型的要求

### 模板编译
当编译器遇到一个模板定义时，它并不生成代码。只有当实例化出模板的一个特定版本时，编译器才会生成代码。当使用(而不是定义)模板时，编译器才生成代码，这一特性影响了如何组织代码以及错误何时被检测到

通常，当调用一个函数时，编译器只需要掌握函数的声明，类似的，当使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现，因此，将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中

模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义

函数模板和类模板成员函数的定义通常放在头文件中

保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任

## 类模板
**类模板**是用来生成类的蓝图的，与函数模板的不同之处是，编译器不能为类模板推断模板参数类型，为了使用类模板，必须在模板名后的尖括号提供额外信息——用来代替模板参数的模板实参列表

### 定义类模板
类似函数模板，类模板以关键字`template`开始，后跟模板参数列表，在类模板(及其成员)的定义中，将模板参数当做替身，代替使用模板时用户需要提供的类型或值

### 实例化类模板
当使用一个类模板时，必须提供额外信息，这些额外信息是**显式模板实参**列表，它们被绑定到模板参数，编译器使用这些模板实参来实例化出特定的类

一个类模板的每个实例都形成一个独立的类，类类型之间没有关联，也不会对任何其他类类型成员有特殊访问权限

### 类模板的成员函数
与其他任何类相同，既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数

定义在类模板之外的成员函数必须以关键字`template`开始，后接类模板参数列表

默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化

在一个类模板的作用域内，可以直接使用模板名而不必指定模板实参


