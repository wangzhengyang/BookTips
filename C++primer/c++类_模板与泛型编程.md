[toc]

模板是C++中泛型编程的基础，一个模板就是一个创建类或函数的蓝图或者说公式

# 定义模板
## 函数模板
以关键字`template`开始，后跟一个**模板参数列表**，这是一个逗号分隔的一个或多个**模板参数**的列表，用小于号(<)和大于号(>)包围起来

在模板定义中，模板参数列表不能为空

### 实例化函数模板
当调用一个函数模板时，编译器(通常)用函数实参来推断模板实参

编译器用推断出的模板参数来为我们**实例化**一个特定版本的函数，当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新实例

### 模板类型参数
模板**类型参数**，可以将它看作类型说明符，就像内置类型或类类型说明符一样使用，特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换

类型参数前必须使用关键字`class`或`typename`，在模板参数列表中，这两个关键字的含义相同，可以互换使用

### 非类型模板参数
非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字`class`或`typename`来指定非类型参数

非类型模板参数的模板实参必须是常量表达式

### 编写类型无关的代码
编写泛型代码的两个重要原则：
1. 模板中的函数参数是`const`的引用
2. 函数体中的条件判断仅使用简单运算

通过将函数参数设定为`const`的引用，保证了函数可以用于不能拷贝的类型

模板程序应该尽量减少对实参类型的要求

### 模板编译
当编译器遇到一个模板定义时，它并不生成代码。只有当实例化出模板的一个特定版本时，编译器才会生成代码。当使用(而不是定义)模板时，编译器才生成代码，这一特性影响了如何组织代码以及错误何时被检测到

通常，当调用一个函数时，编译器只需要掌握函数的声明，类似的，当使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现，因此，将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中

模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义

函数模板和类模板成员函数的定义通常放在头文件中

保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任

## 类模板
**类模板**是用来生成类的蓝图的，与函数模板的不同之处是，编译器不能为类模板推断模板参数类型，为了使用类模板，必须在模板名后的尖括号提供额外信息——用来代替模板参数的模板实参列表

### 定义类模板
类似函数模板，类模板以关键字`template`开始，后跟模板参数列表，在类模板(及其成员)的定义中，将模板参数当做替身，代替使用模板时用户需要提供的类型或值

### 实例化类模板
当使用一个类模板时，必须提供额外信息，这些额外信息是**显式模板实参**列表，它们被绑定到模板参数，编译器使用这些模板实参来实例化出特定的类

一个类模板的每个实例都形成一个独立的类，类类型之间没有关联，也不会对任何其他类类型成员有特殊访问权限

### 类模板的成员函数
与其他任何类相同，既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数

定义在类模板之外的成员函数必须以关键字`template`开始，后接类模板参数列表

默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化

在一个类模板的作用域内，可以直接使用模板名而不必指定模板实参

### 类模板和友元
当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的，如果一个类模板包含一个非模板友元，则友元被授予可以访问所有模板实例，如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例

### 模板类型别名
类模板的一个实例定义了一个类类型，与任何其他类类型一样，可以定义一个`typedef`来引用实例化的类

### 类模板的static成员
类模板可以声明static成员，与任何其他static数据成员相同，模板类的每个static数据成员必须有且仅有一个定义，但是，类模板的每个实例都有一个独有的static对象

## 模板参数
通常将类型参数命名为T

### 使用类的类型成员
当希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class

### 默认模板实参
可以为函数和类模板提供默认实参

### 模板默认实参与类模板
无论何时使用一个类模板，都必须在模板名之后接上尖括号，尖括号指出类必须从一个模板实例化而来，特别是，如果一个类模板为其所有模板参数都提供了默认实参，且希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对

## 成员模板
一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数，这种成员被称为**成员模板**，成员模板不能是虚函数

1. 普通(非模板)类的成员模板
2. 类模板的成员模板

## 控制实例化
当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中，当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件就都会有该模板的一个实例

在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重，通过**显式实例化**来避免这种开销

一个显式实例化有如下形式：
```c++
extern template declartion; //实例化声明
template declaration;   //实例化定义
```
对每个实例化声明，在程序中某个位置必须有其显式的实例化定义

在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数

## 模板实参推断
对于函数模板，编译器利用调用中的函数实参来确定其模板参数，从函数实参来确定模板实参的过程被称为**模板实参推断**，在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本与给定的函数调用最为匹配

### 类型转换与模板类型参数
与非模板函数一样，在一次调用中传递给函数模板的实参被用来初始化函数的形参。如果一个函数形参的类型使用了模板类型参数，那么它采用特殊的初始化规则，只有很有限的几种类型会自动地应用于这些实参，编译器通常不是对实参进行类型转换，而是生成一个新的模板实例

顶层const无论实在形参中还是在实参中，都会被忽略，在其他类型转换中，能在调用中应用于函数模板的包括如下两项：
1. const转换：可以将一个非const对应的引用(或指针)传递给一个const的引用(或指针)形参
2. 数据或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换，一个数组实参可以转换为一个指向其首元素的指针

一个模板类型参数可以用作多个函数形参的类型，由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型，如果推断出的类型不匹配，则调用就是错误的

如果希望允许对函数实参进行正常的类型转换，可以将函数模板定义为两个类型参数

### 正常类型转换应用于普通函数实参
函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型，这种函数实参不进行特殊处理：它们正常转换为对应形参的类型

如果函数参数类型不是模板参数，则对实参进行正常的类型转换

### 函数模板显式实参
在某些情况下，编译器无法推断出模板实参的类型，其他一些情况下，允许用户控制模板实例化，当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常见

提供显式模板实参的方式与定义类模板实例的方式相同，显式模板实参在尖括号中给出，位于函数名之后，实参列表之前

显式模板实参按由左至右的顺序与对应的模板参数匹配

### 正常类型转换引用于显式指定的实参
对于用普通类型定义的函数参数，允许进行正常的类型转换

### 尾置返回类型与类型转换
当希望用户确定返回类型时，用显式模板实参表示模板函数的返回类型时有效的，但在其他情况下，要求显式指定模板是实参会给用户增添额外负担

使用尾置返回类型，出现在参数列表之后，它可以使用函数的参数




