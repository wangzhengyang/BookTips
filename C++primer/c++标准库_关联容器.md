[toc]

#关联容器类型

关联容器中的元素是按关键字来保存和访问的，与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的

关联容器支持高效的关键字查找和访问，两个主要的**关联容器**类型是`map`和`set`

`map`中的元素是一些关键字-值(key-value)对：关键字起到索引的作用，值则表示与索引相关联的数据

`set`中每个元素只包含一个关键字；`set`支持高效的关键字查询操作——检查一个给定关键字是否在`set`中

标准库提供8个关联容器，这8个容器间的不同体现在三个维度上：每个容器(1)或者是一个`set`，或者是一个`map`；(2)或者要求不重复的关键字，或者允许重复关键字；(3)按顺序保存元素，或无序保存

允许重复关键字的容器的名字中都包含单词`multi`

不保持关键字按顺序存储的容器的名字都以单词`unordered`开头

无序容器使用哈希函数来组织元素

`map`和`multimap`定义在头文件`map`中
`set`和`multiset`定义在头文件`set`中
无序容器定义在头文件`unordered_map`和`unordered_set`中

|按关键字有序保存元素|描述|
|-|-|
|map|关联数组：保存关键字-值对|
|set|关键字即值，即只保存关键字的容器|
|multimap|关键字可重复出现的map|
|multiset|关键字可重复出现的set|

|无序集合|描述|
|-|-|
|unordered_map|用哈希函数组织的map|
|unordered_set|用哈希函数组织的set|
|unordered_multimap|哈希组织的map;关键字可以重复出现|
|unordered_multiset|哈希组织的set;关键字可以重复出现|

# 关联容器使用
关联容器(有序的和无序的)都支持普通容器操作，关联容器不支持顺序容器的位置相关的操作，原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义，而且关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作

除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名，此外，无序容器还提供一些用来调整哈希性能的操作

关联容器的迭代器都是双向的

## 定义关联容器
定义`map`时，必须既指明关键字类型又指明值类型，定义`set`时，只需指明关键字类型，因为`set`没有值

每个关联容器定义一个默认构造函数，它创建一个指定类型的空容器，也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转换为容器所需类型就可以

### 初始化`multimap`或·`multiset`
`map`和`set`中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它，容器`multimap`和`multiset`没有此限制，它们都允许多个元素具有相同的关键字

## 关键字类型的要求
对于有序容器——`map`、`multimap`、`set`以及`multiset`，关键字类型必须定义元素的比较的方法，默认情况下，标准库使用关键字类型的`<`运算符来比较两个关键字，在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型

传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求

### 有序容器的关键字类型
可以向一个算法提供自己定义的比较操作，与之类似的，也可以提供自己定义的操作来代替关键字上的`<`运算符，所提供的操作必须在关键字类型上定义一个**严格弱序**，可以将严格弱序看作"小于等于"，必须具备如下基本性质：
1. 两个关键字不能同时"小于等于"对方；如果k1"小于等于"k2，那么k2绝不能"小于等于"k1
2. 如果k1"小于等于"k2，且k2"小于等于"k3，那么k1必须"小于等于"k3
3. 如果存在两个关键字，任何一个都不"小于等于"另一个，那么称这两个关键字是"等价"的，如果k1"等价于"k2，且k2"等价于"k3，那么k1必须"等价于"k3

如果两个关键字是等价的(即，任何一个都不"小于等于"另一个)，那么容器将它们视为相等处理

### 使用关键字类型的比较函数
用来组织一个容器中元素的操作的类型也是该容器类型的一部分，为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型

## `pair`类型
`utility`头文件
一个`pair`保存两个数据成员，类似容器，`pair`是一个用来生产特定类型的模板，当创建一个`pair`时，必须提供两个类型名，`pair`的数据成员将具有对应的类型

与其他标准库类型不同，`pair`的数据成员是public的，两个成员分别命名为`first`和`second`

|操作|描述|
|-|-|
|pair<T1,T2> p;|p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化|
|pair<T1,T2> p(v1,v2)|p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化|
|pair<T1,T2>P={v1,v2}|等价于p(v1,v2)|
|make_pair(v1,v2)|返回一个用v1和v2初始化的pair，pair的类型从v1和v2的类型推断出来|
|p.first|返回p的名为first的(公有)数据成员|
|p.second|返回p的名为second的(公有)数据成员|
|p1 relop p2|关系运算符(<、<=、>、>=)按字典序定义：例如，当p1.first<p2.first或!(p2.first<p1.first && p1.second<p2.second成立时，p1<p2为true，关系运算利用元素的<运算符来实现)|
|p1==p2 p1!=p2|当first和second成员分别相等时，两个pair相等，相等性判断利用元素的==运算符实现|

# 关联容器操作
|额外类型别名|描述|
|-|-|
|key_type|此容器类型的关键字类型|
|mapped_type|每个关键字关联的类型，只适用于map|
|value_type|对于set，与key_type相同 对于map，为pair<const key_type,mapped_type>|

## 关联容器迭代器
当解引用一个关联容器迭代器时，得到一个类型为容器的`value_type`的值的引用，对`map`而言，`value_type`是一个`pair`类型，其`first`成员保存const的关键字，`second`成员保存值

### `set`的迭代器时`const`的
虽然`set`类型同时定义了`iterator`和`const_iterator`类型，但两种类型都只允许只读访问`set`中的元素

### 关联容器和算法
通常不对关联容器使用泛型算法

## 添加元素
对一个`map`进行`insert`操作时，必须记住元素类型是`pair`
|`insert`操作|描述|
|-|-|
|c.insert(v)|v是value_type类型的对象；args用来构造一个元素|
|c.emplace(args)|对于map和set，只有当元素的关键字不在c中时才插入(或构造)元素，函数返回一个pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的bool值|
|c.insert(b,e) c.insert(il)|b和e是迭代器，表示一个c::value_type类型的范围；il是这种值的花括号列表，函数返回void 对于map和set，只插入关键字不在c中的元素，对于multimap和multiset，则会插入范围内的每个元素|
|c.insert(p,v) c.emplace(p,args)|类似insert(v)(或emplace(args))，但将迭代器p作为一个提示，指出从哪里开始搜索新元素应该存储的位置，返回一个迭代器，指向具有给定关键字的元素|

### `insert`返回值
对于不包含重复关键字的容器，添加单一元素的`insert`和`emplace`版本返回一个`pair`，`pair`的`first`成员是一个迭代器，指向具有给定关键字的元素，`second`成员是一个`bool`，指出元素是否插入成功还是已经存在于容器中

## 删除元素
|删除|描述|
|-|-|
|c.erase(k)|从c中删除每个关键字为k的元素，返回一个size_type值，指出删除的元素的数量|
|c.erase(p)|从c中删除迭代器p指定的元素，p必须指向c中一个真实元素，不能等到c.end()，返回一个指向p之后元素的迭代器，若p指向c中的尾元素，则返回c.end()|
|c.erase(b,e)|删除迭代器对b和e所表示的范围中的元素,返回e|

## `map`下标操作
`map`和`unordered_map`容器提供了下标运算符和一个对应的`at`函数，不能对`multimap`和`unordered_multimap`进行下标操作，因为这些容器中可能有多个值与一个关键字相关联

如果关键字并不在`map`中，会为它创建一个元素并插入到`map`找那个，关联值将进行值初始化

|下标操作|描述|
|-|-|
|c[k]|返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化|
|c.at[k]|访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常|

## 访问元素
|查找操作|描述|
|-|-|
|c.find(k)|返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器|
|c.count(k)|返回关键字等于k的元素的数量，对于不允许重复关键字的容器，返回值永远是0或1|
|c.lower_bound(k)|返回一个迭代器，指向第一个关键字不小于k的元素|
|c.uppper_bound(k)|返回一个迭代器，指向第一个关键字大于k的元素|
|c.equal_range(k)|返回一个迭代器pair，表示关键字等于k的元素的范围，若k不存在，pair的两个成员均等于c.end()|

# 无序容器
4个无序关联容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符

如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器

## 管理桶
无序容器在存储上组织为一组桶，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶

|桶接口|描述|
|-|-|
|c.bucket_count()|正在使用的桶的数目|
|c.max_bucket_count()|容器能容纳的最多的桶的数量|
|c.bucket_size(n)|第n个桶中有多少个元素|
|c.bucket(k)|关键字为k的元素在哪个桶中|

|桶迭代|描述|
|-|-|
|local_iterator|可以用来访问桶中元素的迭代器类型|
|const_local_iterator|桶迭代器的const版本|
|c.begin(n),c.end(n)|桶n的首元素迭代器和尾后迭代器|
|c.cbegin(n),c.end(n)|与前两个函数类似，但返回cosnt_local_iterator|

|哈希策略|描述|
|-|-|
|c.load_factor()|每个桶的平均元素数量，返回float值|
|c.max_load_factor()|c试图维护的平均桶大小，返回float值，c会在需要时添加新的桶，以使得load_factor<=max_load_factor|
|c.rehash()|重组存储，使得bucket_count>=n且bucket_cout>size/max_load_factor|
|c.reserve(n)|重组存储，使得c可以保存n个元素且不必rehash|

