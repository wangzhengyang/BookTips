[toc]

**顺序容器**(sequential container)为程序员提供控制元素存储和访问顺序的能力，这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应

# 顺序容器
提供快速顺序访问元素的能力，但是，这些容器在以下方面都有不同的性能折中：
1. 向容器添加或从容器中删除元素的代价
2. 非顺序访问容器中元素的代价

|类型|描述|
|-|-|
|vector|可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢|
|deque|双端队列，支持快速随机访问，在头尾位置插入/删除速度很快|
|list|双向链表，只支持双向顺序访问，在`list`中任何位置进行插入/删除操作速度都很快|
|forward_list|单向链表，只支持单向顺序访问，在链表任何位置插入/删除操作速度都很快|
|array|固定大小数组，支持快速随机访问，不能添加或删除元素|
|string|与`vector`相似的容器，但专门用于保存字符，随机访问块，在尾部插入/删除速度快|

### 顺序容器选择
基本原则：
1. 除非有很好的理由选择其他容器，否则应使用`vector`
2. 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`
3. 如果程序要求随机访问元素，应使用`vector`或`deque`
4. 如果程序要求在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`
5. 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
——首先，确定是否真的需要在容器中间位置添加元素，当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数来重排容器中的元素，从而避免在中间位置添加元素
——如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中

# 容器库概览
一般来说，每个容器都定义在一个头文件中，文件名与类型名相同
## 容器操作
|类型别名|描述|
|-|-|
|iterator|此容器类型的迭代器类型|
|const_iterator|可以读取元素，但不能修改元素的迭代器类型|
|size_type|无符号整数类型，足够保存此种容器类型最大可能容器的大小|
|difference_type|带符号整数类型，足够保存两个迭代器之间的距离|
|value_type|元素类型|
|reference|元素的左值类型；与value_type&含义相同|
|const_reference|元素的const左值类型(即，const value_type&)|

|构造函数|描述|
|-|-|
|C c;|默认构造函数，构造空容器|
|C c1(c2);|构造c2的拷贝c1|
|C c(b, e);|构造c，将迭代器b和e指定的范围内的元素拷贝到c(array 不支持)|
|C c{a, b, c...};|列表初始化c|

|赋值与`swap`|描述|
|-|-|
|c1 = c2|将c1中的元素替换为c2中元素|
|c1 = {a, b, c...}|将c1中的元素替换为列表中元素(不适用于array)|
|a.swap(b)|交换a和b的元素|
|swap(a, b)|与a.swap(b)等价|

|大小|描述|
|-|-|
|c.size()|c中元素的数目(不支持forward_list)|
|c.max_size()|c可保存的最大元素数目|
|c.empty()|若c中存储了元素，返回false，否则返回true|

|添加/删除元素(不适用array)|描述|
|-|-|
|c.insert(args)|将args中的元素拷贝进c|
|c.emplace(inits)|使用inits构造c中的一个元素|
|c.erase(args)|删除args指定的元素|
|c.clear()|删除c中的所有元素，返回void|

|关系运算符|描述|
|-|-|
|==,!=|所有容器都支持相等(不相等)运算符|
|<,<=,>,>=|关系运算符(无序关联容器不支持)|

|获取迭代器|描述|
|-|-|
|c.begin(),c.end()|返回指向c的首元素和尾元素之后位置的迭代器|
|c.cbegin(),c.cend()|返回const_iterator|

|反向容器的额外成员(不支持forward_list)|描述|
|-|-|
|reverse_iterator|按逆序寻址元素的迭代器|
|const_reverse_iterator|不能修改元素的逆序迭代器|
|c.rbegin(),c.rend()|返回指向c的尾元素和首元素之前位置的迭代器|
|c.crbegin(),c.crend()|返回const_reverse_iterator|

## 迭代器
迭代器有着公共的接口，如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的

`forward_list`迭代器不支持递减运算符(--)

## `begin`和`end`成员
当不需要写访问时，应使用`cbegin`和`cend`

## 容器定义和初始化
每个容器类型都定义一个默认构造函数，除`array`之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数
|定义和初始化|描述|
|-|-|
|C c|默认构造函数，如果c是一个`array`，则c中元素按默认方式初始化；否则c为空|
|C c1(c2) C c1=c2|c1初始化为c2的拷贝，c1和c2必须是相同类型(即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于`array`类型，两者还必须具有相同大小)|
|C c{a, b, c...} C c={a, b, c...}|c初始化为初始化列表中元素的拷贝，列表中元素的类型必须与C的元素类型相容。对于`array`类型，列表中元素数目必须等于或小于`array`的大小，任何遗漏的元素都进行值初始化)|
|C c(b, e)|c初始化为迭代器b和e指定范围中的元素的拷贝，范围中元素的类型必须与C的元素类型相容(`array`不适用)|
|C seq(n)|seq包含n个元素，这些元素进行了值初始化；次构造函数是`explicit`的(`string`不适用)|
|C seq(n, t)|seq包含n个初始化为值t的元素|

只有顺序容器(不包含`array`)的构造函数才能接受大小参数

## 赋值和`swap`
|操作|描述|
|-|-|
|c1=c2|将c1中的元素替换为c2中元素的拷贝，c1和c2必须具有相同的类型|
|c={a,b,c...}|将c1中元素替换为初始化列表中元素的拷贝(`array`不适用)|
|swap(c1,c2) c1.swap(c2)|交换c1和c2中的元素，c1和c2必须具有相同的类型，`swap`通常比从c2向c1拷贝元素快得多|
|seq.assign(b,e)|将seq中的元素替换为迭代器b和e所表示的范围中的元素，迭代器b和e不能指向seq中的元素|
|seq.assign(il)|将seq中的元素替换为初始化表il中的元素|
|seq.assign(n,t)|将seq中的元素替换为n个值为t的元素|

`assign`操作不适用于关联容器和`array`
赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而`swap`操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效

除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成

## 关系运算符
1. 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等
2. 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
3. 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果

# 顺序容器操作
## 向顺序容器添加元素
|操作|描述|
|-|-|
|c.push_back(t) c.emplace_back(args)|在c的尾部创建一个值为t或由args创建的元素，返回void|
|c.push_front(t) c.emplace_front(args)|在c的头部创建一个值为t或由args创建的元素，返回void|
|c.insert(p,t) c.emplace(p,args)|在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器|
|c.insert(p,n,t)|在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器；若n为0，则返回p|
|c.insert(p,b,e)|将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回p|
|c.insert(p,il)|il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前，返回指向新添加的第一个元素的迭代器，若列表为空，则返回p|

这些操作都会改变容器的大小，`array`不支持这些操作
`forward_list`有自己的`insert`和`emplace`
`forward_list`不支持`push_back`和`emplace_back`
`vector`和`string`不支持`push_front`和`emplace_front`
向一个`vector`、`string`和`deque`插入元素会使所有指向容器的迭代器、引用和指针失效

当用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身，容器中的元素与提供值的对象之间没有任何关联，随后对容器中元素的任何改变都不会影响到原始对象

## 访问元素
|操作|描述|
|-|-|
|c.back()|返回c中尾元素的引用，若c为空，函数行为未定义|
|c.front()|返回c中首元素的引用，若c为空，函数行为未定义|
|c[n]|返回c中下标为n的元素的引用，n是一个无符号整数，若n>=c.size()，则函数行为未定义|
|c.at(n)|返回下标为n的元素的引用，如果下标越界，则抛出一个`out_of_range`异常|

`at`和下标操作只适用于`string`、`vector`、`deque`和`array`
`back`不适用于`forward_list`

对一个空容器调用`front`和`back`，就像使用一个越界的下标一样，是一种严重的程序设计错误

### 访问成员函数返回的是引用
如果容器是一个`const`对象，则返回值是`const`引用，如果容器不是`const`的，则返回值是普通引用，允许改变元素的值

### 安全随机访问
使用`at`函数实现安全的随机访问

## 删除元素
|操作|描述|
|-|-|
|c.pop_back()|删除c中尾元素，若c为空，则函数行为未定义，函数返回void|
|c.pop_front()|删除c中首元素，若c为空，则函数行为未定义，函数返回void|
|c.erase(p)|删除迭代器p所指定的元素，返回一个指向被删元素之后的元素的迭代器，若p指向尾元素，则返回尾后(off-the-end)迭代器，若p是尾后迭代器，则函数行为未定义|
|c.erase(b, e)|删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器|
|c.clear()|删除c中所有元素，返回void|

这些操作会改变容器大小，所有不适用于`array`
`forward_list`有特殊版本的`erase`
`forward_list`不支持`pop_back`；`vector`和`string`不支持`pop_front`

删除`deque`中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效，指向`vector`或`string`中删除点之后位置的迭代器、引用和指针都会失效

## 特殊`forward_list`操作
|操作|描述|
|-|-|
|lst.before_begin() lst.cbefore_begin()|返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用，`cbefore_begin()`返回一个`const_iterator`
|lst.insert_after(p, t) lst.insert_after(p, n, t) lst.insert_after(p, b, e) lst.insert_after(p, il)|在迭代器p之后的位置插入元素，t是一个对象，n是数量，b和e是表示范围的一对迭代器(b和e不能指向lst内)，il是一个花括号列表，返回一个指向最后一个插入元素的迭代器，如果范围为空，则返回p，若p为尾后迭代器，则函数行为未定义|
|emplace_after(p, args)|使用args在p指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器，若p为尾后迭代器，则函数行为未定义|
|lst.erase_after(p) lst.erase_after(b, e)|删除p指向的位置之后的元素，或删除从b之后直到(但不包含)e之间的元素，返回一个指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器，如果p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义|

## 改变容器大小
|操作|描述|
|-|-|
|c.resize(n)|调整c的大小为n个元素，若n<c.size()，则多出的元素被丢弃，若必须添加新元素，对新元素进行值初始化|
|c.resize(n, t)|调整c的大小为n个元素，任何新添加的元素都初始化为值t|

`resize`不适用于`array`
如果`resize`缩小容器，则指向被删除元素的迭代器、引用和指针都会失效，对`vector`、`string`或`deque`进行`resize`可能导致迭代器、指针和引用失效

## 容器操作可能使迭代器失效
向容器添加元素后：
1. 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效，如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效
2. 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效，如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效
3. 对于`list`和`forward_list`，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍有效

删除一个元素后：
1. 对于`list`和`forward_list`，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、引用和指针仍有效
2. 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效，如果是删除`deque`的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响，如果是删除首元素，这些也不会受影响
3. 对于`vector`和`string`，指向被删元素之前的元素的迭代器、引用和指针仍有效，

当删除元素时，尾后迭代器总是会失效

# `vector`对象增长
为了支持快速随机访问，`vector`将元素连续存储——每个元素紧挨着前一个元素存储
假设容器中的元素是连续存储的，且容器的大小可变的，向`vector`或`string`添加元素，如果没有空间容纳新元素，容器不可能简单地将它添加到内存中其他位置——因为元素必须连续存储，容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间，然后添加新元素，释放旧存储空间
## 管理容量
|操作|描述|
|-|-|
|c.shrink_to_fit()|请将capacity()减少为与size()相同大小|
|c.capacity()|不重新分配内存空间的话，c可以保存多少元素|
|c.reserve(n)|分配至少能容纳n个元素的内存空间|

`shrink_to_fit`只适用于`vector`、`string`和`deque`
`capacity`和`reserve`只适用于`vector`和`string`
`reserve`并不改变容器中元素的数量，它仅影响`vector`预先分配多大的内存空间

# 额外`string`操作
|操作|描述|
|-|-|
|string s(cp, n)|s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符|
|string s(s2, pos2)|s是string s2从下标pos2开始的字符的拷贝，若pos2 > s2.size()，构造函数的行为未定义|
|string s(s2, pos2, len2)|s是string s2从下标pos2开始len2个字符的拷贝，若pos2 > s2.size()，构造函数的行为未定义，不管len2的值是多少，构造函数至多拷贝s2.size() - pos2个字符|
## `substr`操作
|操作|描述|
|-|-|
|s.substr(pos, n)|返回一个string，包含s中从pos开始的n个字符的拷贝，pos的默认值为0，n的默认值为s.size()-pos，即拷贝从pos开始的所有字符|
## 改变`string`其他方法
|操作|描述|
|-|-|
|s.insert(pos, args)|在pos之前插入args指定的字符，pos可以是一个下标或一个迭代器，接受下标的版本返回一个指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器|
|s.erase(pos, len)|删除从位置pos开始的len个字符，如果len被省略，则删除从pos开始直至s末尾的所有字符，返回一个指向s的引用|
|s.assign(args)|将s中的字符替换为args指定的字符，返回一个指向s的引用|
|s.append(args)|将args追加到s，返回一个指向s的引用|
|s.replace(range, args)|删除s中范围range内的字符，替换为args指定的字符，range或者是一个下标和一个长度，或者是一对指向s的迭代器，返回一个指向s的引用|

`args`可以是以下形式之一：`append`和`assign`可以使用所有形式
`str`不能与`s`相同，迭代器`b`和`e`不能指向`s`
|args形式|描述|
|-|-|
|str|字符串str|
|str,pos,len|str中从pos开始最多len个字|
|cp,len|从cp指向的字符数组的前(最多)len个字符|
|n,c|n个字符c|
|b,e|迭代器b和e指定的范围内的字符|
|初始化列表|花括号包围的，以逗号分隔的字符列表|

`replace`和`insert`所允许的`args`形式依赖于`range`和`pos`是如何指定的
|replace(pos,len,args)|replace(b,e,args)|insert(pos,args)|insert(iter,args)|args可以是|
|-|-|-|-|-|
|是|是|是|否|str|
|是|否|是|否|str,pos,len|
|是|是|是|否|cp,len|
|是|是|否|否|cp|
|是|是|是|是|n,c|
|否|是|否|是|b2,e2|
|否|是|否|是|初始化列表|
## `string`搜索操作
