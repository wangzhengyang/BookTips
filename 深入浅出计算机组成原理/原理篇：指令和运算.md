# 原理篇：指令和运算

## 计算机指令

### C语言

```c
// test.c
int main()
{
  int a = 1; 
  int b = 2;
  a = a + b;
}
```

### 汇编

```
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o
```

```
test.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
int main()
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1; 
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  a = a + b;
  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
}
  18:   5d                      pop    rbp
  19:   c3                      ret    
```

## 编译过程

![编译过程](./5.png)

## 指令类型

- [x] **算术类指令**
- [x] **数据传输类指令**
- [x] **逻辑类指令**
- [x] **条件分支类指令**
- [x] **无条件跳转指令**

![](./7.jpeg)

### MIPS指令集

![MIPS指令集](./8.jpeg)

- [x] **R指令**一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的偏移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令
- [x] **I指令**通常用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数
- [x] **J指令**就是一个跳转指令，高6位之外的26位都是一个跳转后的地址

#### 示例

```
add $t0,$s2,$s1
```

![](./9.jpeg)

`add`对应MIPS指令里`opcode`是0，`rs`代表第一个寄存器`s1`的地址是17，`rt`代表第二个寄存器`s2`的地址是18，`rd`代表目标的临时寄存器`t0`的地址，是8。因为不是位移操作，所以位移量都是0

## 指令执行

![](./4.jpg)

- [x] **PC寄存器(指令地址寄存器)**，用来存放下一条需要执行的计算机指令的内存地址
- [x] **指令寄存器**，用来存放当前正在指令的指令
- [x] **条件码寄存器**，用里面的一个一个标记位(Flag)，存放CPU进行计算或者逻辑计算的结果
- [x] **通用寄存器**，用来存储数据和内存地址的寄存器，包括整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等