[toc]

当一个重载的运算符是成员函数时，`this`绑定到左侧运算对象，成员运算符函数的(显式)参数数量比运算对象的对象少一个

除了`::`、`.*`、`.`以及`?:`运算符不能重载外，其他运算符都是可以重载

通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符

1. 如果类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致
2. 如果类的某个操作是检查相等性，则定义`operator==`；如果类有了`operator==`，意味着它通常也应该有`operator!=`
3. 如果类包含一个内在的单序比较操作，则定义`operator<`；如果类有了`operator<`，则它也应该包含其他关系操作
4. 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回`bool`，算数运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用

定义重载运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数，可以遵循以下准则：
1. 赋值(=)、下标([])、调用(())和成员访问箭头(->)运算符必须是成员
2. 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同
3. 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
4. 具有对称性的运算符可能转换任意一端的运算对象，例如算数、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数

# 输入和输出运算符
## 重载输出运算符<<
通常情况下，输出运算符的第一个形参是一个非常量`ostream`对象的引用，之所以`ostream`是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为无法直接复制一个`ostream`对象

第二个形参一般来说是一个常量的引用，该常量是想要打印的类类型，第二个形参是引用的原因是希望避免复制实参；而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容

为了与其他输出对象运算符保持一致，`operator<<`一般要返回它的`ostream`形参

通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符

## 重载输入运算符>>
通常情况下，输入运算符的第一个形参时运算符将要读取的流的引用，第二个形参是将要读入到的(非常量)对象的引用，该运算符通常会返回某个给定流的引用，第二个形参之所以必须是一个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中

输入运算符必须处理输入可能失败的情况，而输出运算符不需要，当读取操作发生错误时，输入运算符应该负责从错误中恢复

# 算术和关系运算符
通常情况下，把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算符对象进行转换，因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用

算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果，如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符，此时，最有效的方式是使用复合赋值来定义算术运算符

如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符

## 相等运算符
通常情况下，C++中的类通过定义相等运算符来检验两个对象是否相等，它会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等

设计准则：
1. 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成`operator==`而非一个普通的命名函数，类定义了`==`运算符之后更容易使用标准库容器和算法
2. 如果类定义了`operator==`，则该运算符应该能判断一组给定的对象中是否含有重复数据
3. 通常情况下，相等运算符应该具有传递性，如果`a==b`和`b==c`都为真，则`a==c`也应该为真
4. 如果类定义了`operator==`，则这个类也应该定义`operator!=`
5. 相等运算符和不相等运算符中的一个应该把工作委托给另一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符

如果某个类在逻辑上有相等性的含义，则该类应该定义`operator==`，这样做可以使得用户更容易使用标准库算符来处理这个类

## 关系运算符
定义了相等运算符的类也常常(但不总是)包含关系运算符，特别是，因为关联容器和一些算符要用到小于运算符，所以定义`operator<`比较有用

通常情况下关系运算符应该
1. 定义顺序关系，令其与关联容器中对关键字的要求一致
2. 如果类同时也含有`==`运算符的话，则定义一种关系令其与`==`保持一致，特别是，如果两个对象是`!=`的，那么一个对象应该`<`另外一个

如果存在唯一一种逻辑可靠的`<`定义，则应该考虑为这个类定义`<`运算符，如果类同时还包含`==`，则当且仅当`<`的定义和`==`产生的结果一致时才定义`<`运算符

# 赋值运算符
拷贝赋值和移动赋值运算符可以把类的一个对象赋值给该类的另一个对象，此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象

不论形参的类型是什么，赋值运算符都必须定义为成员函数

## 复合赋值运算符

赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做，这两类运算符都应该返回左侧运算对象的引用

# 下标运算符
表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符`operator[]`

如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用

## 递增和递减运算符

定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义成类的成员

为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用

后置版本接受一个额外的(不被使用)int类型的形参来区分前置和后置运算符

为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式是一个值而非引用

# 成员访问运算符
在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(->)

箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此

重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象

# 函数调用运算符

函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别

## lambda是函数对象
编写lambda后，编译器将该表达式翻译成一个未命名类的未命名对象，在lambda表达式产生的类中含有一个重载的函数调用运算符

默认情况下lambda不能改变它捕获的变量，因此在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数

## 表示lambda及相应捕获行为的类
当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引的对象确实存在，因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员

通过值捕获的变量被拷贝到lambda中，因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员

lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数，它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定

## 标准库定义的函数对象
`functional`头文件
|算术|关系|逻辑|
|-|-|-|
|plus\<Type>|equal_to\<Type>|logical\<Type>|
|minus\<Type>|not_equal_to\<Type>|logical_or\<Type>|
|multiplies\<Type>|greater\<Type>|logical_not\<Type>|
|divides\<Type>|greater_equal\<Type>||
|modulus\<Type>|less\<Type>||
|negate\<Type>|less_equal\<Type>||

## 可调用对象与`function`
`functional`头文件
|`function`操作|描述|
|-|-|
|function<T> f;| f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同(即T使retType(args)|
|function<T> f(nullptr);|显式地构造一个空function|
|function<T> f(obj);|在f中存储可调用对象obj的副本|
|f|将f作为条件：当f含有一个可调用对象时为真；否则为假|
|f(args)|调用f中的对象，参数是args|
|**定义为function<T>的成员的类型**||
|result_type|该function类型的可调用对象返回的类型|
|argument_type first_argument_type second_argument_type|当T有一个或两个实参时定义的类型，如果T只有一个实参，则argument_type是该类型的同义词；如果T有两个实参，则first_argument_type和second_argument_type分别表示两个实参的类型|

# 重载、类型转换与运算符





