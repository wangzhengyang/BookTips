[toc]

# 事后统计法局限性
1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大
   
# 大O复杂度表示法
## 示例1
```c
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
 /* 代码的执行时间T(n)与每行代码的执行次数成正比*/
```
从CPU角度看，每段代码都执行类似的操作：**读数据-运算-写数据**；尽管每行代码对应的CPU执行的个数、执行的时间都不一样，但是我们假设每行代码执行的时间都一样，为unit_time
## 公式
![](./image/1.png)
T(n)：代表代码执行的时间
n：代表数据规模的大小
f(n)：代表每行代码执行的次数总和
O：代表代码的执行时间T(n)与f(n)表达式成正比

**大O时间复杂度**实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，也叫**渐进时间复杂度**，简称**时间复杂度**

# 时间复杂度分析
1. 只关注循环执行次数最多的一段代码
**在分析一个算法、一段代码的时间复杂度的时候，只关注循环执行次数最多的那一段代码**
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
**总的时间复杂度等于量级最大的那段代码的时间复杂度**
如果T1(n)=O(f(n)),T2(n)=O(g(n)),那么T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
如果T1(n)=O(f(n)),T2(n)=O(g(n));那么T(n)=T1(n)*T2(n)=O(f(n))\*O(g(n))=O(f(n)\*g(n))

# 常见时间复杂度实例分析
![](./image/2.jpg)
复杂度量级分类：**多项式量级**和**非多项式量级**，其中，非多项式量级只有两个：O(2^n)和O(n!)
时间复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Polynomial，非确定多项式)问题
## O(1)
**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)**
## O(logn)、O(nlogn)
**采用大0标记复杂度的时候，可以忽略系数，即O(Cf(n)）=O(f(n))**
## O(m+n)、O(m*n)
当无法评估两个算法谁的量级大，在表示复杂度的时候，就无法省略其中一个

# 空间复杂度
**表示算法的存储空间与数据规模之间的增长关系**
常见的空间复杂度是O(1)、O(n)、O(n^2)，像O(logn)、O(nlogn)这样的对数阶复杂度用不到

# 最好、最坏情况时间复杂度
**最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度**
**最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度**

# 平均情况时间复杂度
也就是概率论中的**加权平均值**，也叫作**期望值**，所以平均时间复杂度的全称叫作**加权平均时间复杂度**或者**期望时间复杂度**

# 均摊时间复杂度
**均摊时间复杂度是一种特殊的平均时间复杂度**

# 内容小结
![](./image/3.jpg)