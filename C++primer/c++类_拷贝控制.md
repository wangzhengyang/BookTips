[toc]

一个类通过定义五种特殊的成员函数来控制对象拷贝、移动、赋值和销毁操作：**拷贝构造函数**(copy constructor)、**拷贝赋值运算符**(copy_assignment operator)、**移动构造函数**(move constructor)、**移动赋值运算符**(move-assignment operator)和**析构函数**(destructor)

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作

# 拷贝、赋值与销毁
## 拷贝构造函数
拷贝构造函数的第一参数必须是一个引用类型，此参数总是一个`const`的引用
拷贝构造函数通常不应该是`explicit`的

即使定义了其他构造函数，编译器也会合成一个拷贝构造函数

对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝

拷贝初始化不仅在用`=`定义变量时会发生，在下列情况下也会发生
1. 将一个对象作为实参传递给一个非引用类型的形参
2. 从一个返回类型为非引用类型的函数返回一个对象
3. 用花括号列表初始化一个数组中的元素或一个聚合类的成员

## 拷贝赋值运算符
赋值运算符就是一个名为`operator=`的函数

赋值运算符通常应该返回一个指向其左侧运算对象的引用

如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**(synthesized copy-assignment operator)

## 析构函数
释放对象使用的资源，并销毁对象的非static数据成员

析构函数不接受参数，因此它不能被重载

在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化，在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁

隐式销毁一个内置指针类型的成员不会`delete`它所指的对象

**与普通指针不同，智能指针是类类型，所以具有析构函数，因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁**

一个对象被销毁，自动调用其析构函数的情况：
1. 变量在离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器(无论是标准库容器还是数组)被销毁时，其元素被销毁
4. 对于动态分配的对象，当对指向它的指针应用`delete`运算符时被销毁
5. 对于临时对象，当创建它的完整表达式结束时被销毁

由于析构函数自动运行，程序可以按需要分配资源，而(通常)无须担心何时释放这些资源

**当指向一个对象的引用或指针离开作用域时，析构函数不会执行**

当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**(synthesized destructor)，类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁，如果不是这种情况，合成析构函数的函数体就为空

在(空)析构函数体执行完毕后，成员会被自动销毁

析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的

## 三/五法则
1. 需要析构函数的类也需要拷贝和赋值操作

如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数

2. 需要拷贝操作的类也需要赋值操作，反之亦然

## 使用`=default`
将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本

在类内使用`=default`修饰成员的声明时，合成的函数将隐式声明为内联的

只能对具有合成版本的成员函数使用`=default`(即，默认构造函数或拷贝控制成员或析构函数)

## 阻止拷贝
在函数的参数列表后面加上`=delete`来指出希望将它定义为删除的

于`=default`不同，`=delete`必须出现在函数第一次声明的时候

与`=default`另一个不同的是，可以对任何函数指定`=delete`

不能删除析构函数，如果析构函数被删除，就无法销毁此类型的对象，对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针

以下情况，编译器将这些合成的成员定义为删除的函数：
1. 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
2. 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的，如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的
3. 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个`const`的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
4. 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个`const`成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的

本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的

希望阻止拷贝的类应该使用`=delete`来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为`private`的

# 拷贝控制和资源管理
## 定义行为像值的类
编写赋值运算符时，需要：
1. 如果将一个对象赋予它自身，赋值运算符必须能正确工作
2. 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中，当拷贝完成后，销毁左侧运算对象的现有成员是安全的，一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了

对于赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作，一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象

## 定义行为像指针的类
令一个类展现类似指针的行为的最好方法是使用`shared_ptr`来管理类中的资源，在某些情况下，使用`引用计数`来完成直接地资源管理
### 引用计数
引用计数的工作方式如下：
1. 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态，当创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
2. 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享
3. 析构函数递减计数器，指出共享状态的用户少一个，如果计数器变为0，则析构函数释放状态
4. 拷贝赋值运算符递增右侧对象的计数器，递减左侧运算对象的计数器，如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户，拷贝赋值运算符就必须销毁状态

# 交换操作
如果一个类定义了自己的`swap`，那么算法将使用类自定义版本，否则，算法将使用标准库定义的`swap`

与拷贝控制成员不同，`swap`并不是必要的，但是，对于分配了资源的类，定义`swap`可能是一种重要的优化手段

定义`swap`的类通常用`swap`来定义它们的赋值运算符，使用一种**拷贝并交换**(copy and swap)技术，这种技术将左侧运算对象与右侧运算对象的一个副本进行交换

使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值

# 对象移动
在旧C++标准中，没有直接的方法移动对象，因此，即使不必拷贝对象的情况下，也不得不拷贝，如果对象较大，或者是对象本身要求分配内存空间，进行不必要的拷贝代价非常高

标准库容器、`string`和`shared_ptr`类既支持移动也支持拷贝，IO类和`unique_ptr`类可以移动但不能拷贝

## 右值引用
**左值**：指的是有地址的变量，可以位于等号左边
**右值**：指的是没有地址的字面值、临时值，只能位于等号右边

**左值引用**：能指向左值，不能指向右值(但是`const`左值引用可以指向右值)
**右值引用**：可以指向右值，不能指向左值
右值引用能指向右值，本质上就是把右值提升为一个左值

通过`std::move`将右值引用指向左值

1. 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝
2. 右值引用可以直接指向右值，也可以通过`std::move`指向左值；而左值引用只能指向左值(`const`左值引用也能指向右值)
3. 作为函数形参时，右值引用更加灵活，虽然`const`左值引用也可以做到左右值都接受，但它无法修改，有一定局限性

左值有持久的状态，而右值要么是字面常量，要么是在表达式求职过程中创建的临时对象

由于右值引用只能绑定到临时对象，所以得知
1. 所引用的对象将要被销毁
2. 该对象没有其他用户

这意味着，使用右值引用的代码可以自由地接管所引用的对象的资源

## 移动构造函数和移动赋值运算符
与拷贝构造函数不同，移动构造函数不分配任何新内存，它接管给定的对象的内存，在接管内存之后，它将给定对象中的指针都置为`nullptr`，这样就完成从给定对象的移动操作，此对象将继续存在，最终，移动后源对象会被销毁，意味着将其上运行析构函数

由于移动操作“窃取”资源，它通常不分配任何资源，因此，移动操作通常不会抛出任何异常，当编写一个不抛出异常的移动操作时，应该将此事通知标准库，使用`noexcept`

必须在类头文件的声明中和定义中(如果定义在类外的话)都指定`noexcept`

由于一个移后源对象具有不确定的状态，对其调用`std::move`是危险的，当调用`move`时，必须绝对确认移后源对象没有其他用户








