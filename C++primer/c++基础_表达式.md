[toc]

# 基础
## 基本概念
一元运算符是作用于一个运算对象的运算符
二元运算符是作用于两个运算对象的运算符
三元运算符是作用于三个运算对象的运算符
函数调用也是一种特殊的运算符，它对运算对象的数量没有限制
### 组合运算符和运算对象
含有多个运算符的复杂表达式来说，要理解运算符的优先级(precedence)、结合律(associativity)以及运算对象的求值顺序(order of evaluation)
### 运算对象转换
一般二元运算符都要求两个运算对象的类型相同，但是很多时候即使运算对象的类型不相同也没有关系，只要它们能被转换成同一种类型即可
### 重载运算符
当运算符作用于类类型的运算对象时，用户可以自行定义其含义

使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的
### 左值和右值
C语言的定义：左值可以位于赋值语句的左侧，右值则不能

C++语言的定义：当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的位置)

重要原则：在需要右值的地方可以用左值来替代，但是不能把右值当成左值(也就是位置)使用；当一个左值被当成右值使用时，实际使用的是它的内容

1. 赋值运算符需要一个(非常量)左值作为其左侧运算对象，得到的结果也仍然是一个左值
2. 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值
3. 内置解引用运算符、下标运算符、迭代器解引用运算符、`string`和`vector`的下标运算符的求值结果都是左值
4. 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值

使用关键字`decltype`的时候，左值和右值也有所不同，如果表达式的求值结果是左值，`decltype`作用于该表达式(不是变量)得到一个引用类型

## 优先级与结合律
括号无视优先级与结合律

## 求值顺序
优先级规定运算对象的组合方式，但是没有说明运算对象按照什么顺序求值
int i = f1() * f2();
f1和f2一定会在执行乘法之前被调用，因为相乘的是这两个函数的返回值，但是无法知道f1在f2之前调用还是f2在f1之前调用
有4种运算符明确规定运算对象的求值顺序，逻辑与(&&)运算符、逻辑或(||)运算符、条件(?:)运算符和逗号(,)运算符

1. 用括号来强制让表达式的组合关系符合程序逻辑的要求
2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象(当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效)

# 算术运算符(左结合律)
一元运算符的优先级最高，接下来是乘法和除法，优先级最低的是加法和减法，优先级高的运算符比优先级低的运算符组合得更紧密

|运算符|功能|用法|
|-|-|-|
|+|一元正号|+ expr|
|-|一元负号|- expr|
|*|乘法|expr * expr|
|/|除法|expr / expr|
|%|求余|expr % expr|
|+|加法|expr + expr|
|-|减法|expr - expr|

# 逻辑和关系运算符
|结合律|运算符|功能|用法|
|-|-|-|-|
|右|!|逻辑非|!expr|
|左|<|小于|expr < expr|
|左|<=|小于等于|expr <= expr|
|左|>|大于|expr > expr|
|左|>=|大于等于|expr >= expr|
|左|==|相等|expr == expr|
|左|!=|不相等|expr != expr|
|左|&&|逻辑与|expr && expr|
|左|\|\||逻辑或|expr \|\| expr|

**短路求值**(short-circuit evaluation)
1. 对于逻辑与运算符来说，当且仅当左侧运算符对象为真时才对右侧运算对象求值
2. 对于逻辑或运算符来说，当且仅当左侧运算符为假时才对右侧运算符对象求值

# 赋值运算符
赋值运算符的左侧运算对象必须是一个可修改的左值

# 递增和递减运算符
递增运算符(++)和递减运算符(--)为对象的提供加1和减1操作，这两个运算符可应用于迭代器，因为很多迭代器本身不支持算术运算

前置版本，首先将运算对象加1(或减1)，然后将改变后的对象作为求值结果
后置版本，也会将运算对象加1(或减1)，但是求值结果是运算对象改变之前那个值的副本

在C++中，除非必须，否则不用递增递减运算符的后置版本，后置版本需要将原始值存储下来以便于返回这个未修改的内容，如果不需要修改前的值，那么后置版本的操作就是一种浪费，而且对于相对复杂的迭代器类型，这种额外的工作消耗是巨大的

# 成员访问运算符
点运算符和箭头运算符都可用于访问成员

# 条件运算符
(?:)允许把简单的if-else逻辑嵌入到单个表达式当中
```
cond ? expr1 : expr2
```

# 位运算符(左结合律)
|运算符|功能|用法|
|-|-|-|
|`|位求反|expr|
|<<|左移|expr1 << expr2|
|>>|右移|expr1 >> expr2|
|&|位与|expr & expr|
|^|位异或|expr ^ expr|
|\||位或|expr \| expr|

# `sizeof`运算符
```c++
sizeof(type)
sizeof type
```
1. 对char或者类型为char的表达式执行sizeof运算，结果得1
2. 对引用类型执行sizeof运算得到被引用对象所占空间的大小
3. 对指针执行sizeof运算得到指针本身所占空间的大小
4. 对解引用指针执行sizeof得到指针指向的对象所占空间的大小，指针不需有效
5. 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将得到的结果求和，注意，sizeof运算不会把数组转换成指针处理
6. 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间

# 逗号运算符
含有两个运算对象，按照从左向右的顺序依次求值

# 类型转换
隐式类型转换
1. 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
2. 在条件中，非布尔值转换成布尔类型
3. 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
4. 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
5. 函数调用时也会发生类型转换

## 算术转换
**整型提升**负责把小整数类型转换成较大的整数类型

## 其他隐式类型转换
数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

指针的转换：常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void*

转换成布尔类型：如果指针或算术类型的值为0，转换结果是false；否则转换结果是true

转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也同样

类类型定义的转换：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换

## 显示转换
```
cast-name<type>(expression);
```
`static_cast` 任何具有明确定义的类型转换，只要不包含底层const，都可以使用`static_cast`
`const_cast`只能改变运算对象的底层const
`reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释，本质上依赖于及其，要想安全地使用，必须对设计的类型和编译器实现转换的过程非常了解

# 运算符优先级表
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|::|全局作用域|::name|
|左|::|类作用域|class::name|
|左|::|命名空间作用域|namespace::name|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|.|成员选择|object.member|
|左|->|成员选择|pointer->member|
|左|[]|下标|expr[expr]|
|左|()|函数调用|name(expr_list)|
|左|()|类型构造|type(expr_lsit)|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|右|++|后置递增运算|lvalue++|
|右|--|后置递减运算|lvalue--|
|右|typeid|类型ID|typeid(type)|
|右|typeid|运行时类型ID|typeid(expr)|
|右|explicit cast|类型转换|cast_name< type>(expr)|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|右|++|前置递增运算|++lvalue|
|右|--|前置递减运算|--lvalue|
|右|\`|位求反|`expr|
|右|!|逻辑非|!expr|
|右|-|一元负号|-expr|
|右|+|一元正号|+expr|
|右|\*|解引用|*expr|
|右|&|取地址|&lvalue|
|右|()|类型转换|(type)expr|
|右|sizeof|对象的大小|sizeof expr|
|右|sizeof|类型的大小|sizeof(type)|
|右|sizeof...|参数包的大小|sizeof...(name)|
|右|new|创建对象|new type|
|右|new[]|创建数组|new type[size]|
|右|delete|释放对象|delete expr|
|右|delete[]|释放数组|delete[] expr|
|右|noexcept|能否抛出异常|noexcept(expr)|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|->*|指向成员选择的指针|ptr->*ptr_to_member|
|左|.*|指向成员选择的指针|obj.*ptr_to_member|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|*|乘法|expr*expr|
|左|/|除法|expr/expr|
|左|%|取模(取余)|expr%expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|+|加法|expr+expr|
|左|-|减法|expr-expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|<<|向左移位|expr<<expr|
|左|<=|小于等于|expr<=expr|
|左|>|大于|expr>expr|
|左|>=|大于等于|expr>=expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|==|相等|expr==expr|
|左|!=|相等|expr!=expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|&|位与|expr&expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|^|位异或|expr^expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|\||位或|expr\|expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|&&|逻辑与|expr&&expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|\|\||逻辑或|expr\|\|expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|右|?:|条件|expr?expr:expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|右|=|赋值|lvalue=expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|右|*=,/=,&=|复合赋值|lvalue+=expr等|
|右|+=,-=|复合赋值|lvalue+=expr等|
|右|<<=,>>=|复合赋值|lvalue+=expr等|
|右|&=,|=,^=|复合赋值|lvalue+=expr等|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|右|throw|抛出异常|throw expr|

---
|结合律|运算符|功能|用法|
|-|-|-|-|
|左|,|逗号|expr,expr|
