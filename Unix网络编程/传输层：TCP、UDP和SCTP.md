[toc]

# 用户数据报协议(UDP)
UDP是一个简单的传输层协议，应用进程往一个UDP套接字写入一个消息，该消息随后被封装到一个UDP数据报，该UDP数据报进而又被封装到一个IP数据报，然后发送到目的地，UDP不保证UDP数据报会到达其最终目的地，不保证各个数据报的先后顺序跨网络后保持不变，也不保证每个数据报只到达一次
UDP提供无连接的服务，因为UDP客户与服务器之间不必存在任何长期的关系

# 传输控制协议(TCP)
TCP提供客户与服务器之间的连接，TCP客户先于某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接
其次，TCP还提供了可靠性，当TCP向另一端发送数据时，它要求对端返回一个确认，如果没有收到确认，TCP就自动重传数据并等待更长时间，在数次重传失败后，TCP才放弃，如此在尝试发送数据上所花的总时间一般为4~10分钟(依据具体实现)

TCP含有用于**动态估算客户和服务器之间的往返时间(round-trip time, RTT)的算法**，以便它知道等待一个确认需要多少时间

TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序

TCP提供流量控制，TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据，这称为**通告窗口**，在任何时刻，该窗口指出接收缓冲区中当前可用的空间量，从而确保发送端发送的数据不会使接收缓冲区溢出。该窗口时刻动态变化：当接收到来自发送端的数据时，窗口大小就减少，但是当接收端应用从缓冲区中读取数据时，窗口大小就增大，通告窗口大小减小到0是有可能的：当TCP对应某个套接字的接收缓冲区已满，导致它必须等待应用从该缓冲区读取数据时，方能从对端再接收数据

TCP连接是全双工的，这意味着在一个给定的连接上应用可以在任何时刻在进出两个方向上既发送数据又接收数据，因此，TCP必须为每个数据流方向跟踪诸如序列号和通告窗口大小等状态信息，建立一个全双工连接后，需要的话可以把它转换成一个单工连接

# TCP连接的建立和终止
## 三路握手
1. 服务器必须准备好接受外来的连接。通常通过调用`socket`、`bind`和`listen`这三个函数来完成，称之为**被动打开**
2. 客户端通过调用`connect`发起**主动打开**，这导致客户TCP发送一个SYN(同步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号，通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部及可能有的TCP选项
3. 服务器必须确认(ACK)客户的SYN，同时也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号，服务器在单个分节中发送SYN和对客户SYN的ACK(确认)
4. 客户必须确认服务器的SYN
![](../UNIX网络编程/image/1.png)

## TCP选项
1. MSS选项。发送SYN的TCP一端使用本选项通告对端它的最大分节大小(maximum segment size)即MSS，也就是它在本连接的每个TCP分节中愿意接受的最大数据量，发送端TCP使用接收端的MSS值作为所发送分节的最大大小
2. 窗口规模选项。TCP连接任何一端能够通告对端的最大窗口大小是65535，因为在TCP首部中相应的字段占16位
3. 时间戳选项。

## TCP连接终止
1. 某个应用程序进程首先调用`close`，称该端执行**主动关闭**，该端的TCP于是发送一个FIN分节，表示数据发送完毕
2. 接收到这个FIN的对端执行**被动关闭**，这个FIN由TCP确认。它的接收也作为一个文件结束符传递给接收端应用程序(放在已排队等候该应用程序进程接收的任何其他数据之后)，因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收
3. 一段时间后，接收到这个文件结束符的应用进程将调用`close`关闭它的套接字，这导致它的TCP也发送一个FIN
4. 接收这个最终FIN的原发送端TCP(即执行主动关闭的那一段)确认这个FIN
![](../UNIX网络编程/image/2.png)

无论是客户还是服务器，任何一端都可以执行主动关闭，通常情况下是客户执行主动关闭

## TCP状态转换图
TCP为一个连接定义了11种状态，并且TCP规则规定如何基于当前状态及在该状态下所接受的分节从一个状态转换到另一个状态

粗实线表示通常的客户状态转换，用粗虚线表示通常的服务器状态转换
![](../UNIX网络编程/image/3.png)

## 观察分组
![](../UNIX网络编程/image/4.png)
一旦建立一个连接，客户就构造一个请求并发送给服务器，这里假设该请求适合于单个TCP分节(即请求大小小于服务器通告的值为1460字节的MSS)，服务器处理该请求并发送一个应答，假设该应答也适合于单个分节(即小于536字节)，注意服务器对客户请求的确认是伴随其应答发送的，这种做法称为`捎带`，它通常在服务器处理请求并产生应该的时间小于200s时发生，如果服务器耗用更长时间，譬如说1s，那么将先看到确认后是应答

如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答，那么使用TCP有8个分节的开销，如果改用UDP，那么只需要交换两个分组：一个承载请求，一个承载应答，然而从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的一大堆细节从传输层(TCP)转移到UDP应用进程

TCP提供的另一个重要特性即拥塞控制也必须由UDP应用进程来处理

# TIME_WAIT状态
执行主动关闭的那端经历这个状态，该端点停留在这个状态的持续时间是最长分节生命期(maximum segment lifetime，MSL)的两倍

任何TCP实现都必须为MSL选择一个值，MSL是任何IP数据报能够在因特网中存活的最长时间，这个时间是有限的，因为每个数据报含有一个称为跳限(hop limit)的8位字段，它的最大值为255，尽管这是一个跳限限制而不是真正的时间限制，我们仍然假设：具有最大跳限(255)的分组在网络中存在的时间不可能超过MSL秒





