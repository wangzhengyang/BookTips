[toc]

# 空间配置器(allocator)

**allocator**是空间配置器而不是内存配置器是因为空间不一定是内存，空间也可以是磁盘或其他辅助存储介质

## 空间配置器的标准接口
- [x] allocator::value_type
- [x] allocator::pointer
- [x] allocator::const_pointer
- [x] allocator::reference
- [x] allocator::const_reference
- [x] allocator::size_type
- [x] allocator::difference_type
- [x] allocator:rebind

一个嵌套的(nested)class template，class rebind(U)拥有唯一成员other，那是一个typedef，代表allocator\<U>

- [x] allocator::allocator()

默认构造函数

- [x] allocator::allocator(const allocator&)

默认拷贝构造函数

- [x] template \<class U>allocator::allocator(const allocator\<U>&)

泛化的拷贝构造函数

- [x] allocator::~allocator()

默认析构函数

- [x] pointer allocator::address(reference x) const

返回某个对象的地址

- [x] const_pointer allocator::address(const_reference x) const

返回一个const对象的地址

- [x] pointer allocator::allocate(size_type n, const void* = 0)

配置空间，足以存储n个T对象，第二参数是个提示，实际上可能会利用它来增进区域性(locality)，或完全忽略之

- [x] void allocator::deallocate(pointer p, size_type n)

归还先前配置的空间

- [x] size_type allocator::max_size() const

返回可成功配置的最大量

- [x] void allocator::construct(pointer p, const T& x)

等价于new((const void*)p) T(x)

- [x] void allocator::destroy(pointer p)

等价于p->~T()

## 简单的空间配置器

```c++
#ifndef ALLOCATOR_H
#define ALLOCATOR_H

#include <new>
#include <cstddef>
#include <cstdlib>
#include <climits>
#include <iostream>

namespace a
{

template <class T>
inline T* _allocate(ptrdiff_t size, T*){
    set_new_handler(0);
    T* tmp = (T*)(::operator new((size_t)(size * sizeof(T))));
    if(tmp == 0){
        cerr << "out of memory" << endl;
        exit(1);
    }
    return tmp;
}

template <class T>
intline void _deallocate(T* buffer){
    ::operator delete(buffer);
}

template <class T1, class T2>
inline void _construct(T1* p, const T2& value){
    new(p) T1(value);
}

template <calss T>
inline void _destroy(T* ptr){
    ptr->~T();
}

template <class T>
class allocator{
public:
    typedef T           value_type;
    typedef T*          pointer;
    typedef const T&    const_pointer;
    typedef T&          reference;
    typedef const T&    const_reference;
    typedef size_t      size_type;
    typedef ptrdiff_t   difference_type;

    template<class U>
    struct rebind{
        typedef allocator<U> other;
    };

    pointer allocate(size_type n, const void* hint = 0){
        return _allocate((difference_type)n, (pointer)0);
    }

    void deallocate(pointer p, size_type n){
        _deallocate(p);
    }

    void construct(pointer p, const T& value){
        _construct(p, value);
    }

    void destroy(pointer p){
        _destroy(p);
    }

    pointer address(reference x) {
        return (pointer)&x;
    }

    const_pointer const_address(const_reference x){
        return (const_pointer)&x;
    }

    size_type max_size() const{
        return size_type(UINT_MAX/sizeof(T));
    }
};
}

#endif
```

## SGI标准的空间配置器 std::allocator
虽然SGI也定义有一个符合部分标准、名为`allocator`的配置器，但SGI从未用过它，主要原因是效率不佳，只是把C++的`::operator new`和`::operator delete`做了一层封装
```c++
#ifndef DEFALLOC_H
#define DEFALLOC_H

#include <new.h>
#include <stddef.h>
#include <stdlib.h>
#include <limits.h>
#include <iostream.h>
#include <algobase.h>

template <class T>
int T* allocate(ptrdiff_t size, T*){
    set_new_handler(0);
    T* tmp = (T*)(::operator new((size_t)(size * sizeof(T))));
    if(tmp == 0){
        cout << "out of memory" << endl;
        exit(1);
    }
    return tmp;
}

template <class T>
inline void deallocate(T* buffer){
    ::operator delete(buffer);
}

template <class T>
class allocator{
public:
    typedef T           value_type;
    typedef T*          pointer;
    typedef const T*    const_pointer;
    typedef T&          reference;
    typedef const T&    const_reference;
    typedef size_t      size_type;
    typedef ptrdiff_t   difference_type;

    pointer allocate(size_type n){
        return ::allocate((difference_type)n, (pointer)0);
    }

    void deallocate(pointer p){
        ::deallocate(p);
    }

    pointer address(reference x){
        return (pointer)&x;
    }

    const_pointer const_address(const_reference x){
        return (const_pointer)&x;
    }

    size_type init_page_size(){
        return max(size_type(1), size_type(4096/sizeof(T)));
    }

    size_type max_size() const{
        return max(size_type(1), size_type(UINT_MAX/sizeof(T)));
    }
};

class allocator<void>{
public:
    typdef void* pointer;
};

#endif
```
## SGI特殊的空间配置器std::alloc
`allocator`只是基层内存配置/释放行为(`::operator new`和`::operator delete`)的封装，没有考虑任何效率

`new`算式内含两阶段操作：(1)调用`::operator new`配置内存;(2)调用构造函数构造对象；`delete`算式内含两个阶段操作：(1)调用析构函数对对象析构;(2)调用`::operator delete`释放内存

STL allocator将两阶段操作区分开来，内存配置操作由`alloc:allocate()`负责，内存释放操作由`alloc::deallocate`负责；对象构造操作由`::construct()`负责，对象析构操作由`::destroy`负责

配置器定义于`<memory>`之中，内含两个文件：
```c++
#include <stl_alloc.h>      //负责内存空间的配置和释放
#include <stl_construct.h>  //负责对象内容的构造和析构
```

## 构造和析构基本工具：`construct()`和`destroy()`
定义在`<stl_construct.h>`中
```c++
#include <new.h>

template <class T1, class T2>
inline void construct(T1* p, const T2& value){
    new(p) T1(value); //调用T1::T1(value)
}

template <class T>
inline void destroy(T* pointer){
    pointer->~T();
}

template <class ForwardIterator>
inline void destroy(ForwardIterator first, ForwardIterator last){
    __destroy(first, last, value_type(first));
}

template <class ForwardIterator, class T>
inline void __destroy(ForwardIterator first, ForwardIterator last, T*)
{
    typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;
    __destroy_aux(first, last, trivial_destructor());
}

template <class ForwardIterator>
inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type){
    for(; first < last; ++first){
        destroy(&*first);
    }
}

template <class ForwardIterator>
inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type){}

inline void destroy(char*, char*){}
inline void destroy(wchar_t*, wchar_t*){}
```
`construct()`接受一个指针p和一个初值value，该函数的用途就是将初值设定到指针所指的空间上，使用`new`完成这个任务

`destroy()`有两个版本，第一版本接受一个指针，准备将该指针所指之物析构掉，通过直接调用该对象的析构函数即可，第二版本接受`first`和`last`两个迭代器，准备将`[first, last)`范围内的所有对象析构掉，但是并不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓trivial destructor)，那么一次次调用这些析构函数，对效率是一种伤害，因此，首先利用`value_type()`获得迭代器所指对象型别，再利用`__type_traits<T>`判断该型别的析构函数是否无关痛痒，若是`__true_type`，则什么也不做；若否`__false_type`，才以循环方式访问整个范围，并在循环中每经历一个对象就调用第一个版本的`destroy()`

## 空间的配置与释放 std::alloc
由`<stl_alloc.h>`负责，SGI对此的设计哲学如下：
1. 向system heap要求空间
2. 考虑多线程(multi-thread)状态
3. 考虑内存不足时的应变措施
4. 考虑过多"小型区块"可能造成的内存碎片(fragment)问题

C++的内存配置基本操作是`::operator new()`，内存释放基本操作是`::operator delete()`，这两个全局函数相当于C的`malloc()`和`free()`函数，所以SGI以`malloc()`和`free()`完成内存的配置与释放

考虑到小型区块所可能造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器直接使用`malloc()`和`free()`，第二级配置器则视情况采用不同的策略：当配置区块超过128bytes时，便调用第一级配置器；当配置区块小于128bytes，为了降低额外负担，便采用复杂的memory pool整理方式，而不再求助第一级配置器，整个设计究竟只开放第一级配置器，或是同时开放第二级配置，取决于`__USE_MALLOC`是否被定义
```c++
#ifdef __USE_MALLOC
...
typedef __malloc_alloc_template<0> malloc_alloc;
typedef malloc_alloc alloc;
#else
...
typedef __default_alloc_tempalte<__NODE_ALLOCATOR_THREADS, 0> alloc;
#endif
```
其中`__malloc_alloc_template`就是第一级配置器，`__default_alloc_template`就是第二级配置器

无论`alloc`被定义为第一级或第二级配置器，SGI还再包装一个接口
```c++
template<class T, class Alloc>
class simple_alloc{
public:
    static T *allocate(size_t n){
        return 0 == n? 0 : (T*)Alloc::allocate(n * sizeof(T));
    }

    static T *allocate(void){
        return (T*)Alloc::allocate(sizeof(T));
    }

    static void deallocate(T *p, size_t n){
        if (0 != n)
            Alloc::deallocate(p, n * sizeof(T));
    }

    static void deallocate(T *p){
        Alloc::deallocate(p, sizeof(T));
    }
};
```

SGI STL容器全都使用这个`simple_alloc`接口
```c++
template<class T, class Alloc = alloc>
class vector{
protected:
    typedef simple_alloc<value_type, Alloc> data_allocator;

    void deallocate(){
        if(...){
            data_allocator::deallocate(start, end_of_storage - start);
        }
    }
}
```