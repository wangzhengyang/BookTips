[toc]

#关联容器类型

关联容器中的元素是按关键字来保存和访问的，与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的

关联容器支持高效的关键字查找和访问，两个主要的**关联容器**类型是`map`和`set`

`map`中的元素是一些关键字-值(key-value)对：关键字起到索引的作用，值则表示与索引相关联的数据

`set`中每个元素只包含一个关键字；`set`支持高效的关键字查询操作——检查一个给定关键字是否在`set`中

标准库提供8个关联容器，这8个容器间的不同体现在三个维度上：每个容器(1)或者是一个`set`，或者是一个`map`；(2)或者要求不重复的关键字，或者允许重复关键字；(3)按顺序保存元素，或无序保存

允许重复关键字的容器的名字中都包含单词`multi`

不保持关键字按顺序存储的容器的名字都以单词`unordered`开头

无序容器使用哈希函数来组织元素

`map`和`multimap`定义在头文件`map`中
`set`和`multiset`定义在头文件`set`中
无序容器定义在头文件`unordered_map`和`unordered_set`中

|按关键字有序保存元素|描述|
|-|-|
|map|关联数组：保存关键字-值对|
|set|关键字即值，即只保存关键字的容器|
|multimap|关键字可重复出现的map|
|multiset|关键字可重复出现的set|

|无序集合|描述|
|-|-|
|unordered_map|用哈希函数组织的map|
|unordered_set|用哈希函数组织的set|
|unordered_multimap|哈希组织的map;关键字可以重复出现|
|unordered_multiset|哈希组织的set;关键字可以重复出现|

# 关联容器使用
关联容器(有序的和无序的)都支持普通容器操作，关联容器不支持顺序容器的位置相关的操作，原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义，而且关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作

除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名，此外，无序容器还提供一些用来调整哈希性能的操作

关联容器的迭代器都是双向的

## 定义关联容器
定义`map`时，必须既指明关键字类型又指明值类型，定义`set`时，只需指明关键字类型，因为`set`没有值

每个关联容器定义一个默认构造函数，它创建一个指定类型的空容器，也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转换为容器所需类型就可以

### 初始化`multimap`或·`multiset`
`map`和`set`中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它，容器`multimap`和`multiset`没有此限制，它们都允许多个元素具有相同的关键字

## 关键字类型的要求
对于有序容器——`map`、`multimap`、`set`以及`multiset`，关键字类型必须定义元素的比较的方法，默认情况下，标准库使用关键字类型的`<`运算符来比较两个关键字，在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型

传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求

### 有序容器的关键字类型
可以向一个算法提供自己定义的比较操作，与之类似的，也可以提供自己定义的操作来代替关键字上的`<`运算符，所提供的操作必须在关键字类型上定义一个**严格弱序**，可以将严格弱序看作"小于等于"，必须具备如下基本性质：
1. 两个关键字不能同时"小于等于"对方；如果k1"小于等于"k2，那么k2绝不能"小于等于"k1
2. 如果k1"小于等于"k2，且k2"小于等于"k3，那么k1必须"小于等于"k3
3. 如果存在两个关键字，任何一个都不"小于等于"另一个，那么称这两个关键字是"等价"的，如果k1"等价于"k2，且k2"等价于"k3，那么k1必须"等价于"k3

如果两个关键字是等价的(即，任何一个都不"小于等于"另一个)，那么容器将它们视为相等处理

### 使用关键字类型的比较函数
用来组织一个容器中元素的操作的类型也是该容器类型的一部分，为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型

## `pair`类型
`utility`头文件
一个`pair`保存两个数据成员，类似容器，`pair`是一个用来生产特定类型的模板，当创建一个`pair`时，必须提供两个类型名，`pair`的数据成员将具有对应的类型

与其他标准库类型不同，`pair`的数据成员是public的，两个成员分别命名为`first`和`second`

|操作|描述|
|-|-|
|pair<T1,T2> p;|p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化|
|pair<T1,T2> p(v1,v2)|p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化|
|pair<T1,T2>P={v1,v2}|等价于p(v1,v2)|
|make_pair(v1,v2)|返回一个用v1和v2初始化的pair，pair的类型从v1和v2的类型推断出来|
|p.first|返回p的名为first的(公有)数据成员|
|p.second|返回p的名为second的(公有)数据成员|
|p1 relop p2|关系运算符(<、<=、>、>=)按字典序定义：例如，当p1.first<p2.first或!(p2.first<p1.first && p1.second<p2.second成立时，p1<p2为true，关系运算利用元素的<运算符来实现)|
|p1==p2 p1!=p2|当first和second成员分别相等时，两个pair相等，相等性判断利用元素的==运算符实现|

# 关联容器操作
|额外类型别名|描述|
|-|-|
|key_type|此容器类型的关键字类型|
|mapped_type|每个关键字关联的类型，只适用于map|
|value_type|对于set，与key_type相同 对于map，为pair<const key_type,mapped_type>|

## 关联容器迭代器
当解引用一个关联容器迭代器时，得到一个类型为容器的`value_type`的值的引用，对`map`而言，`value_type`是一个`pair`类型，其`first`成员保存const的关键字，`second`成员保存值

### `set`的迭代器时`const`的
虽然`set`类型同时定义了`iterator`和`const_iterator`类型，但两种类型都只允许只读访问`set`中的元素

### 关联容器和算法
通常不对关联容器使用泛型算法

## 添加元素
对一个`map`进行`insert`操作时，必须记住元素类型是`pair`
