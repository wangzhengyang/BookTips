[toc]

# 套接字地址结构
## IPv4套接字地址结构
定义在`<netinet/in.h>`
IPv4套接字地址地沟通常称为“网际套接字地址结果”，以`sockaddr_in`命名
```c
struct in_addr{
    in_addr_t s_addr;   //32-bit IPv4 address network byte ordered
};

struct sockaddr_in{
    uint8_t sin_len;    //length of struct(16)
    sa_family_t sin_family; //AF_INET
    in_port_t sin_port; //16-bit TCP or UDP port number network byte ordered

    struct in_addr sin_addr; /32-bit IPv4 address network byte ordered

    char sin_zero[8]; //unused
};
```
POSIX规范只需要结构中的3个字段：`sin_family`、`sin_addr`和`sin_port`

|数据类型|说明|头文件|
|-|-|-|
|int8_t|带符号的8位整数|<sys/types.h>|
|uint8_t|无符号的8位整数|<sys/types.h>|
|int16_t|带符号的16位整数|<sys/types.h>|
|uint16_t|无符号的16位整数|<sys/types.h>|
|int32_t|带符号的32位整数|<sys/types.h>|
|uint32_t|无符号的32位整数|<sys/types.h>|
|sa_family_t|套接字地址结构的地址族|<sys/socket.h>|
|socklen_t|套接字地址结构的长度，一般为uint32_t|<sys/socket.h>|
|in_addr_t|IPv4地址，一般为uint32_t|<netinet/in.h>|
|in_port_t|TCP或UDP端口，一般为uint16_t|<netinet/in.h>|

## 通用套接字地址结构
`<sys/socket.h>`头文件定义一个通用的套接字地址结构
```c
struct sockaddr{
    uint8_t sa_len;
    sa_family_t sa_family;  //address family: AF_XXX value
    char sa_data[14];
};

int bind(int, struct sockaddr *, socklen_t);
```

```c
strcut sockaddr_in serv;

bind(sockfd, (struct sockaddr*)&serv, sizeof(serv));
```

## IPv6套接字地址结构
`<netinet/in.h>`头文件中定义
```c
struct in6_addr{
    uint8_t s6_addr[16];    //128-bit IPv6 address network byte ordered
};

#define SIN6_LEN    //required for compile-time tests

struct sockaddr_in6{
    uint8_t sin6_len;   //length of this struct(28)
    sa_family_t sin6_family;    /AF_INET6
    in_port_t   sin6_port;  //transport layer port network byte ordered
    
    uint32_t sin6_flowinfo; //flow information, undefined
    struct in6_addr sin6_addr; //IPv6 address network byte ordered

    uint32_t sin6_scope_id; //set of interfaces for a scope
};
```
## 新的通用套接字地址结构
`<netinet/in.h>`头文件定义
```c
struct sockaddr_storage{
    uint8_t ss_len;     //lenght of this struct (implementation dependent)
    sa_family_t ss_family;  //address family: AF_XXX value
    /*  implemetaion-dependent elements to provide:
    *   a) aligment sufficient to fulfill the alignment requiredments of. 
    *      all socket address types that the system supports.
    *   b) enough storage to hold any type of socket address that the system
    *      system supports.
    */
};
```

# 值-结果参数
(1)从进程到内核传递套接字地址结构的函数有3个：`bind`、`connect`和`sendto`，这些函数的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小
```c
struct sockaddr_in serv;
connect(sockfd, (SA*)&serv, sizeof(serv));
```
(2)从内核到进程传递套接字地址结构的函数有4个：`accept`、`recvfrom`、`getsockname`和`getpeername`，这些函数的其中两个参数是指向某个套接字地址结构的指针和指向表示该结构大小的整数变量的指针
```c
struct sockaddr_un cli; //unix domain
socklen_t len;

len = sizeof(cli);
getpeername(unixfd, (SA*)&cli, &len);
```

# 字节排序函数
```c
#include <netinet/in.h>

uint16_t htons(uint16_t host16bitvalue);
uint32_t htonl(uint32_t host32bitvalue);    //均返回：网络字节序的值

uint16_t ntohs(uint16_t net16bitvalue);
uint32_t ntohl(uint32_t net32bitvalue);     //均返回：主机字节序的值
```

# 字节操作函数
```c
#include <strings.h>

void bzero(void *dest, size_t nbytes);
void bcopy(const void *src, void *dest, size_t nbytes);
int bcmp(const void *ptr1, const void *ptr2, size_t nbytes);    //返回：若相等则为0，否则为非0
```

```c
#include <string.h>

void *memset(void *dest, int c, size_t len);
void *memcpy(void *dest, const void *src, size_t nbytes);
int memcmp(const void *ptr1, const void *ptr2, size_t nbytes);  //返回：若相等则为0，否则为<0或者>0
```

# 地址转换函数
## `inet_aton`、`inet_addr`和`inet_ntoa`函数
`inet_aton`、`inet_addr`和`inet_ntoa`在点分十进制数串与它长度为32位的网络字节序二进制值间转换IPv4地址
```c
#include <arpa/inet.h>

int inet_aton(const char *strptr, struct in_addr, *addrptr);    //返回：若字符串有效则为1，否则为0

in_addr_t inet_addr(const char *strptr) //返回：若字符串有效则为32位二进制网络字节序的IPv4地址，否则为INADDR_NONE

char *inet_ntoa(struct in_addr inaddr); //返回：指向一个点分十进制数串的指针
```

## `inet_pton`和`inet_ntop`函数
```c
#include <arpa/inet.h>

int inet_pton(int family, const char *strptr, void *addrptr); //返回：若成功则为1，若输入不是有效的表达格式则为0，若出错则为-1

const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len); //返回：若成功则为指向结果的指针，若出错则为NULL
```

`inet_ntop`中`len`参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区，为有助于指定这个大小，在`<netinet/in.h>`头文件中有如下定义：
```c
#define INET_ADDRSTRLEN     16  //for IPv4 dotted-decimal
#define INET6_ADDRSTRLEN    46  //for IPv6 hex string
```

只支持IPv4的`inet_pton`函数
```c
int inet_pton(int family, const char *strptr, void *addrptr)
{
    if (family == AF_INET){
        struct in_addr in_val;
        if(inet_aton(strptr, &in_val)){
            memcpy(addrptr, &in_val, sizeof(struct in_addr));
            return 1;
        }
        return 0;
    }
    errno = EAFNOSUPPORT;
    return -1;
}

const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len)
{
    const u_char *p = (const u_char*)addrptr;
    if(family == AF_INET){
        char temp[INET_ADDRSTRLEN];
        snprintf(temp, sizeof(temp), "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
        if(strlen(temp) >= len){
            errno = ENOSPC;
            return NULL;
        }
        strcpy(strptr, temp);
        return strptr;
    }
    errno = EAFNOSUPPORT;
    return NULL;
}
```

# `sock_ntop`和相关函数
`inet_ntop`的一个基本问题是：它要求调用者传递一个指向某个二进制地址的指针，而该地址通常包含在一个套接字地址结构中，这就要求调用者必须知道这个结构的格式和地址族
```c
struct sockaddr_in addr;
inet_ntop(AF_INET, &addr.sin_addr, str, sizeof(str));

strcut sockaddr_in6 addr6;
inet_ntop(AF_INET6, &addr.sin6_addr, str, sizeof(str));
```

自定义函数`sock_ntop`
```c
#include "unp.h"

char *sock_ntop(const struct sockaddr *sa, socklen_t salen)
{
    char portstr[8];
    static char str[128];   //unix domain is largest

    switch(sa->sa_family){
    case AF_INET:    
        struct sockaddr_in *sin = (struct sockaddr_in*)sa;
        if(inet_ntop(AF_INET, &sin->sin_addr, str, sizeof(str)) == NULL)
            return NULL;
        if(ntohs(sin->sin_port) != 0){
            snprintf(portstr, sizeof(portstr), ":%d", ntohs(sin->sin_port));
            strcat(str, portstr);
        }
        return str;
    }
}
```

# `readn`、`writen`和`readn`函数
字节流套接字上的`read`和`write`函数所表现的行为不同于通常的文件I/O，字节流套接字上调用`read`和`write`输入和输出的字节数可能比请求的数量少，然而这不是出错的状态，原因在于内核中用于套接字的缓冲区可能已达到了极限，此时所需的是调用者再次调用`read`和`write`函数，以输入或输出剩余的字节

```c
#include "unp.h"

ssize_t readn(int fd, void *vptr, size_t n)
{
    size_t nleft;
    ssize_t nread;

    char *ptr;
    ptr = vptr;

    nleft = n;
    while(nleft > 0){
        if((nread = read(fd, ptr, nleft)) < 0){
            if(errno == EINTR){
                nread = 0;
            }else{
                return -1;
            }
        }else if(nread == 0){
            break;
        }

        nleft -= nread;
        ptr += nreadk;
    }
    return (n - nleft);
}

ssize_t writen(int fd, const void *vptr, size_t n)
{
    size_t nleft;
    ssize_t nwritten;
    const char *ptr;

    ptr = vptr;
    nleft = n;

    while(nleft > 0){
        if((nwritten = write(fd, ptr, nleft)) <= 0){
            if (nwritten < 0 && errno == EINTR){
                nwrittten = 0;
            }else{
                return -1;
            }
        }
        nleft -= nwritten;
        ptr += nwritten;
    }
    return n;
}

//PAINFULLY SLOW VERSION
ssize_t readline(int fd, void *vptr, size_t maxlen)
{
    ssize_t n, rc;
    char c, *ptr;

    ptr = vptr;
    for(n = 1; n < maxlen; n++){
    again:
        if((rc = read(fd, &rc, 1)) == 1){
            *ptr++ = c;
            if(c == '\n'){
                break;
            }
        }else if(rc == 0){
            *ptr = 0;
            return (n - 1);
        }else{
            if(errno == EINTR){
                goto again;
            }
            return -1;
        }
    }
    *ptr = 0;
    return (n);
}

//FASTER VERSION
static int read_cnt;
static char *read_ptr;
static char read_buf[MAXLINE];

static ssize_t my_read(int fd, char *ptr)
{
    if(read_cnt <= 0){
    again:
        if((read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0){
            if(errno == EINTR){
                goto again;
            }
            return -1;
        }else if(read_cnt == 0){
            return 0;
        }
        read_ptr = read_buf;
    }
    read_cnt--;
    *ptr = *read_ptr++;
    return (1);
}

ssize_t readline(int fd, void *vptr, size_t maxlen)
{
    ssize_t n, rc;
    char c, *ptr;

    ptr = vptr;
    for(n = 1; n < maxlen; n++){
        if((rc = my_read(fd, &c)) == 1){
            *ptr++ = c;
            if(c == '\n')
                break;
        }else if(rc == 0){
            *ptr = 0;
            return (n - 1);
        }else{
            return -1;
        }
    }
    *ptr = 0;
    return n;
}

ssize_t readlinebuf(void **vptrptr)
{
    if(read_cnt){
        *vptrptr = read_ptr;
    }
    return read_cnt;
}
```