[toc]

大多数算法定义在`algorithm`头文件
一组数值泛型算法定义在`numeric`头文件

# 算法如何工作
1. 迭代器令算法不依赖于容器
2. 算法依赖于元素类型的操作

泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作，所以算法永远不会改变底层容器的大小，算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素

# 泛型算法类型
## 只读算法

1. 查找某个值

`find(vec.cbegin(), vec.cend(), val)`

2. 求和

`numeric`头文件

`accumulate(vec.cbegin(), vec.cend(), init)`

前两个指出需要求和的元素的范围，第三个参数是和的初值

`accumulate`的第三个参数的类型决定函数中使用哪个加法元素符以及返回值的类型

对于只读取而不改变元素的算法，通常最好使用`cbegin()`和`cend()`

3. 确定两个序列是否保存相同的值

`equal(vec1.cbegin(), vec1.cend(), vec2.cbegin())`

可以比较两个不同类型的容器中的元素，而且元素类型也不必一样，只要能用`==`来比较两个元素类型即可

但是`equal`基于一个假设：它假定第二个序列至少与第一个序列一样长，此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素

那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长

## 写容器元素算法

1. 填充

`fill(vec.begin(), vec.end(), val)`
`fill_n(vec.begin(), size, val)`

`fill_n`必须假定向目的位置迭代器写入数据的算法时，目的位置足够大，能容纳要写入的元素

2. 拷贝

`copy(vec.cbegin(), vec.cend(), dst)`

前两个表示一个输入范围，第三个表示目的序列的起始位置

传递给`copy`的目的序列至少要包含与输入序列一样多的元素

`copy`返回的是其目的位置迭代器(递增后)的值

3. 替换

`replace(vec.begin(), vec.end(), val1, val2)`

将范围内的val1的值替换成val2的值

`replace_copy(vec1.cbegin(), vec1.cend(), back_inserter(vec2), val1, val2)`
将范围内的val1的值替换成val2的值装入到新的容器中

## `back_inserter`插入迭代器
一种向容器中添加元素的迭代器，通常情况下，当通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素，而当通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中

`iterator`头文件

`back_iterator`接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器，当通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中

## 重排容器元素算法

1. 排序

`sort(vec.begin(), vec.end())`

2. 相邻重复项"消除"

`unique(vec.begin(), vec.end())`

将相邻的重复项"消除"，并返回一个指向不重复值范围末尾的迭代器

如果需要删除元素，需要通过容器来进行删除操作

# 定制操作
很多算法会比较输入序列中的元素，默认情况下，算法使用元素类型的<或==运算符完成比较，但是标准库也为这些算法定义额外的版本，允许提供自定义的操作来替代默认运算符

## 向算法传递函数
### 谓词
谓词是一个可调用的表达式，其返回结果是一个能用作条件的值，标准库算法所使用的谓词分为两类：**一元谓词**(unary predicate，只接受单一参数)和**二元谓词**(binary predicate，接受两个参数)

接受谓词参数的算符对输入序列中的元素调用谓词，因此，元素类型必须能转换为谓词的参数类型





