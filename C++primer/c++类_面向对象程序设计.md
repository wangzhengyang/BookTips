[toc]

# OOP概述
面对对象程序设计的核心思想是数据抽象、继承和动态绑定；通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

## 继承
通过**继承**联系在一起的类构成一种层次关系，通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类**，基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员

在C++语言汇总，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待，对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类将这些函数声明成**虚函数**

派生类必须通过使用**类派生列表**明确指出它是从哪个基类继承而来的

## 动态绑定
在C++语言中，当使用基类的引用(或指针)调用一个虚函数时将发生动态绑定

# 定义基类和派生类
## 定义基类
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

## 定义派生类
在派生类对象中含有与基类对应的组成部分，这一事实是继承的关键所在

尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员，和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分

首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

派生类可以访问基类的公有成员和受保护成员

### 继承与静态成员
如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例

静态成员遵循通用的访问控制规则，如果基类中的成员是`private`的，则派生类无权访问它，假设某静态成员是可访问的，则既能通过基类使用它也能通过派生类使用它

通过类名后面加关键字`final`，防止继承发生

## 类型转换与继承
存在继承关系的类，可以将基类的指针或引用绑定到派生类对象上，当使用基类的引用(或指针)时，实际上并不清楚该引用(或指针)所绑定对象的真实类型，该对象可能是基类的对象，也可能是派生类的对象

和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着可以将一个派生类对象的指针存储在一个基类的智能指针上

当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动和赋值，它的派生类部分将被忽略掉

# 虚函数
在C++语言中，当使用基类的引用或指针调用一个虚成员函数时会执行动态绑定，因为直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义

通常情况下，如果不使用某个函数，则无须为该函数提供定义，但是必须为每一个虚函数都提供定义，而不管它是否被用到，这是因为连编译器也无法确定到底会使用哪个虚函数

当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同

基类中的虚函数在派生类中隐含地也是一个虚函数，当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配

使用`override`标记某个函数来说明派生类中的虚函数

如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致

## 回避虚函数机制
使用域运算符实现这一目的

通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制

如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无线递归

# 抽象基类
一个纯虚函数无序定义，可以通过在函数体的位置(即在声明语句的分号之前)书写`=0`将一个虚函数说明为纯虚函数，`=0`只能出现在类内部的虚函数声明语句处

含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类，抽象基类负责定义接口，而后续的其他类可以覆盖该接口

不能创建抽象基类的对象

# 访问控制与继承
一个类使用`protected`关键字来声明那么它希望与派生类分享但是不想被其他公共访问使用的成员，`protected`说明符可以看做是`public`和`private`中和后的产物：
1. 和私有成员类似，受保护的成员对于类的用户来说是不可访问的
2. 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的，此外`protected`还有另外一条重要的性质：派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权

不能继承友元关系；每个类负责控制各自成员的访问权限

## 改变个别成员的可访问性
有时需要改变派生类继承的某个名字的访问级别，通过使用`using`声明可以达到这一目的

派生类只能为那么它可以访问的名字提供`using`声明

默认派生运算符是由定义派生类所用的关键字来决定，默认情况下，使用`class`关键字定义的派生类是私有继承的；而使用`struct`关键字定义的派生类是公有继承的

一个私有派生的类组好显式地将`private`声明出来，而不要仅仅依赖于默认的设置，显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会

# 继承中的类作用域
当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义

派生类的成员将隐藏同名的基类成员

如果派生类(即内层作用域)的成员与基类(即外层作用域)的某个成员同名，则派生类将在其作用域内隐藏该基类成员，即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉

# 构造函数与拷贝控制
## 虚析构函数
继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样才能动态分配继承体系中的对象

当`delete`一个动态分配的对象的指针时将执行析构函数，如果，如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况，所以通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本

和其他虚函数一样，析构函数的虚属性也会被继承，如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为

一个基类总是需要析构函数，而且它能将析构函数设定为虚函数，该析构函数为了成为虚函数而令内容为空，所以无法由此推断该基类还需要赋值运算符或拷贝构造函数

## 虚析构函数将阻止合成移动操作
基类需要一个虚析构函数，即使它通过`=default`的形式使用了合成的版本，编译器也不会为这个类合成移动操作

## 合成拷贝控制与继承
基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作

## 移动操作与继承
大多数基类都会定义一个虚析构函数，因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作

因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当确实需要执行移动操作时应该首先在基类中进行定义

## 派生类的拷贝控制成员
派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分，因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员，类似的，派生类赋值运算符也必须为其基类部分的成员赋值

和构造函数以赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源，对象的成员是被隐式销毁的，类似的，派生类对象的基类部分也是自动销毁的

当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象

## 定义派生类的拷贝或移动构造函数
在默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝(或移动)构造函数

## 派生类赋值运算符
与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值

## 派生类析构函数
在析构函数体执行完成后，对象的成员会被隐式销毁，类似的，对象的基类部分也是隐式销毁的，因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源

对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后

如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本

# 容器与继承
当使用容器存放继承体系中的对象时，通常必须采取间接存储的方式，因为不允许在容器中保存不同类型的元素，所以不能把具有继承关系的多种类型的对象直接存放在容器当中

当派生类对象被赋予给基类对象时，其中的派生类部分将被"切掉"，因此容器和存在继承关系的类型无法兼容

## 在容器中放置(智能)指针而非对象
当希望在容器中存放具有继承关系的对象时，实际上存放的通常是基类的指针(更好的选择是智能指针)

## 隐藏指针-模拟虚拷贝
```c++
class Quote{
public:
    virtual Quote* clone() const & {return new Quote(*this);}
    virtual Quote* clone() && {return new Quote(std::move(*this));}
};

class Bulk_quote : public Quote{
    Bulk_quote* clone() const & {return new Bulk_quote(*this);}
    Bulk_quote* clone() && {return new Bulk_quote(std::move(*this));}
};

class Basket{
public:
    void add_item(const Quote& sale){ items.insert(std::shared_ptr<Quote>(sale.clone()));}
    void add_item(Quote&& sale){items.insert(std::shared_ptr<Quote>(std::move(sale).clone()));}
};
```

