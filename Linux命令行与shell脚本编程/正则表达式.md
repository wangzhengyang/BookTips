[toc]

# 正则表达式定义
Linux工具用定义的模式模板来过滤文本，Linux工具(比如sed编辑器或gawk程序)能够在处理数据时使用正则表达式对数据进行模式匹配，如果数据匹配模式，它会被接受并进一步处理；如果数据不匹配模式，它就会被滤掉
正则表达式模式利用通配符来描述数据流中的一个或多个字符
# 正则表达式类型
正则表达式是通过正则表达式引擎(regular expression engine)实现的，它是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配
在Linux中，两种流行的正则表达式引擎：
(1)POSIX基础正则表达式(basic regular expression, BRE)引擎
(2)POSIX扩展正则表达式(extended regular expression, ERE)引擎
# 定义BRE模式
## 纯文本
正则表达式模式区分大小写，它并不关心模式在数据流中的位置，也不关心模式出现了多少次，一旦正则表达式匹配了文本字符串中任意位置上的模式，它就会将该字符串传回Linux工具
在正则表达式中，不用写出整个单词，反之则不行
不用局限于在正则表达式中只用单个文本单词，可以在正则表达式中使用空格和数字
## 特殊字符
`.*[]^${}\+?|()`都是正则表达式可以识别的特殊字符
如果用到某个特殊字符作为文本字符，通过反斜线(\)完成转义
## 锚字符
### 锁定在行首
脱字符(`^`)定义从数据流中文本行的行首开始的模式，如果模式出现在行首之外的位置，正则表达式则无法匹配
```bash
echo "The book store" | sed -n '/^book/p'
echo "Books are great" | sed -n '/^Book/p'
```
如果将脱字符放在模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符
### 锁定在行尾
特殊字符美元符(`$`)定义行尾锚点，将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾
```bash
echo "This is a good book" | sed -n '/book$/p'
echo "This book is good" | sed -n '/book$/p'
```
### 组合锚点
可以在同一行中将行首锚点和行尾锚点组合在一起使用
第一种情况中，假定要查找只含有特定文本模式的数据行
```bash
sed -n '/^this is a test$/p' data4
```
第二种情况中，将两个锚点直接组合在一起，之间不加任何文本，过滤出数据流中的空白行
```bash
sed '/^$/d' data5
```
## 点号字符
用来匹配除换行符之外的任意单个字符，它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式不成立
空格也是一个字符
```bash
sed -n '/.at/p' data6
```
## 字符组
用来匹配文本模式中某个位置的一组字符，如果字符组中的某个字符出现在了数据流中，就匹配该模式
使用方括号来定义一个字符组，方括号中包含所有你希望出现在该字符组中的字符
```bash
sed -n '/[ch]at/p' data6
```
在不确定某个字符大小写时，字符组非常有用
```bash
sed -n '/[Yy]es/p' data
```
在单个表达式中用多个字符组
```bash
sed -n '/[Yy][Ee][Ss]/p' data
```
字符组不必只含有字母，也可以在其中使用数字
## 排除型字符组
使用脱字符去寻找组中没有的字符，而不是去寻找组中含有的字符
```bash
sed -n '/^[ch]at/p' data
```
## 区间
用单破折线符号在字符组中表示字符区间
```bash
sed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data
```
方法也适用于字母
```bash
sed -n '/[c-h]at/p' data
```
在单个字符组指定多个不连续的区间
```bash
sed -n '/[a-ch-m]at/p' data
```
## 特殊字符组
|组|描述|
|-|-|
|\[[:alpha:]]|匹配任意字母字符，不管是大写还是小写|
|\[[:alnum:]]|匹配任意字母数字字符0-9、A-Z或a-z|
|\[[:blank:]]|匹配空格或制表符|
|\[[:digit:]]|匹配0-9之间的数字|
|\[[:lower:]]|匹配小写字母字符a-z|
|\[[:print:]]|匹配任意可打印字符|
|\[[:punct:]]|匹配标点符号|
|\[[:space:]]|匹配任意空白字符：空格、制表符、NL、FF、VT和CR|
|\[[:upper:]]|匹配任意大写字母字符A-Z|
## 星号
在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次
```bash
sed -n '/ie*k/p'
```
将点号特殊字符和星号特殊字符组合起来，能够匹配任意数量的任意字符，通常用于在数据流中两个可能相邻或不相邻的文本字符串之间
```bash
sed -n '/regular.*expression/p'
```
星号作用到字符组上，允许指定可能在文本中出现多次的字符组或字符区间
```bash
sed -n '/b[ae]*t/p'
```
# 扩展正则表达式
## 问号
问号表明前面的字符可以出现0次或1次，但仅限于此，它不会匹配多次出现的字符
```bash
gawk '/be?t/{print $0}'
```
将问号和字符组一起使用
```bash
gawk '/b[ae]?t/{print $0}'
```
## 加号
加号表明前面的字符可以出现1次或多次，但必须至少出现1次，如果该字符没有出现，那么模式就不会匹配
```bash
gawk '/be+t/{print $0}'
```
将加号与字符组一起使用
```bash
gawk '/b[ae]+t/{print $0}'
```
## 使用花括号
允许为可重复的正则表达式指定一个上限，通常称为间隔(interval)，用两种格式来指定区间
(1)m:正则表达式准确出现m次
(2)m,n：正则表达式至少出现m次，至多n次
```bash
gawk --re-interval '/be{1}t/{print $0}'
gawk --re-interval '/be{1,2}t/{print $0}'
```
## 管道符号
用逻辑OR方式指定正则表达式引擎要用的两个或多个模式；如果任何一个模式匹配了数据流文本，文本就通过测试
管道格式：
```bash
expr1|expr2|...
```
```bash
gawk '/cat|dog/{print $0}'
```
## 表达式分组
用圆括号进行分组，当你将正则表达式模式分组时，该组会被视为一个标准字符，可以像对普通字符一样给该组使用特殊字符
```bash
gawk '/Sat(urday)?/{print $0}'
gawk '/(c|b)a(b|t)/{print $0}'
```