[toc]

一个类通过定义五种特殊的成员函数来控制对象拷贝、移动、赋值和销毁操作：**拷贝构造函数**(copy constructor)、**拷贝赋值运算符**(copy_assignment operator)、**移动构造函数**(move constructor)、**移动赋值运算符**(move-assignment operator)和**析构函数**(destructor)

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作

# 拷贝、赋值与销毁
## 拷贝构造函数
拷贝构造函数的第一参数必须是一个引用类型，此参数总是一个`const`的引用
拷贝构造函数通常不应该是`explicit`的

即使定义了其他构造函数，编译器也会合成一个拷贝构造函数

对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝

拷贝初始化不仅在用`=`定义变量时会发生，在下列情况下也会发生
1. 将一个对象作为实参传递给一个非引用类型的形参
2. 从一个返回类型为非引用类型的函数返回一个对象
3. 用花括号列表初始化一个数组中的元素或一个聚合类的成员

## 拷贝赋值运算符
赋值运算符就是一个名为`operator=`的函数

赋值运算符通常应该返回一个指向其左侧运算对象的引用

如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**(synthesized copy-assignment operator)

## 析构函数
释放对象使用的资源，并销毁对象的非static数据成员

析构函数不接受参数，因此它不能被重载

在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化，在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁

隐式销毁一个内置指针类型的成员不会`delete`它所指的对象

**与普通指针不同，智能指针是类类型，所以具有析构函数，因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁**

一个对象被销毁，自动调用其析构函数的情况：
1. 变量在离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器(无论是标准库容器还是数组)被销毁时，其元素被销毁
4. 对于动态分配的对象，当对指向它的指针应用`delete`运算符时被销毁
5. 对于临时对象，当创建它的完整表达式结束时被销毁

由于析构函数自动运行，程序可以按需要分配资源，而(通常)无须担心何时释放这些资源

**当指向一个对象的引用或指针离开作用域时，析构函数不会执行**

当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**(synthesized destructor)，类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁，如果不是这种情况，合成析构函数的函数体就为空

在(空)析构函数体执行完毕后，成员会被自动销毁

析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的

## 三/五法则
1. 需要析构函数的类也需要拷贝和赋值操作

如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数

2. 需要拷贝操作的类也需要赋值操作，反之亦然

## 使用`=default`
将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本

在类内使用`=default`修饰成员的声明时，合成的函数将隐式声明为内联的

只能对具有合成版本的成员函数使用`=default`(即，默认构造函数或拷贝控制成员或析构函数)

## 阻止拷贝
在函数的参数列表后面加上`=delete`来指出希望将它定义为删除的

