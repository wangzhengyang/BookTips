[toc]

**顺序容器**(sequential container)为程序员提供控制元素存储和访问顺序的能力，这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应

# 顺序容器
提供快速顺序访问元素的能力，但是，这些容器在以下方面都有不同的性能折中：
1. 向容器添加或从容器中删除元素的代价
2. 非顺序访问容器中元素的代价

|类型|描述|
|-|-|
|vector|可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢|
|deque|双端队列，支持快速随机访问，在头尾位置插入/删除速度很快|
|list|双向链表，只支持双向顺序访问，在`list`中任何位置进行插入/删除操作速度都很快|
|forward_list|单向链表，只支持单向顺序访问，在链表任何位置插入/删除操作速度都很快|
|array|固定大小数组，支持快速随机访问，不能添加或删除元素|
|string|与`vector`相似的容器，但专门用于保存字符，随机访问块，在尾部插入/删除速度快|

### 顺序容器选择
基本原则：
1. 除非有很好的理由选择其他容器，否则应使用`vector`
2. 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`
3. 如果程序要求随机访问元素，应使用`vector`或`deque`
4. 如果程序要求在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`
5. 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
——首先，确定是否真的需要在容器中间位置添加元素，当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数来重排容器中的元素，从而避免在中间位置添加元素
——如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中

# 容器库概览
一般来说，每个容器都定义在一个头文件中，文件名与类型名相同
## 容器操作
|类型别名|描述|
|-|-|
|iterator|此容器类型的迭代器类型|
|const_iterator|可以读取元素，但不能修改元素的迭代器类型|
|size_type|无符号整数类型，足够保存此种容器类型最大可能容器的大小|
|difference_type|带符号整数类型，足够保存两个迭代器之间的距离|
|value_type|元素类型|
|reference|元素的左值类型；与value_type&含义相同|
|const_reference|元素的const左值类型(即，const value_type&)|

|构造函数|描述|
|-|-|
|C c;|默认构造函数，构造空容器|
|C c1(c2);|构造c2的拷贝c1|
|C c(b, e);|构造c，将迭代器b和e指定的范围内的元素拷贝到c(array 不支持)|
|C c{a, b, c...};|列表初始化c|

|赋值与`swap`|描述|
|-|-|
|c1 = c2|将c1中的元素替换为c2中元素|
|c1 = {a, b, c...}|将c1中的元素替换为列表中元素(不适用于array)|
|a.swap(b)|交换a和b的元素|
|swap(a, b)|与a.swap(b)等价|

|大小|描述|
|-|-|
|c.size()|c中元素的数目(不支持forward_list)|
|c.max_size()|c可保存的最大元素数目|
|c.empty()|若c中存储了元素，返回false，否则返回true|

|添加/删除元素(不适用array)|描述|
|-|-|
|c.insert(args)|将args中的元素拷贝进c|
|c.emplace(inits)|使用inits构造c中的一个元素|
|c.erase(args)|删除args指定的元素|
|c.clear()|删除c中的所有元素，返回void|

|关系运算符|描述|
|-|-|
|==,!=|所有容器都支持相等(不相等)运算符|
|<,<=,>,>=|关系运算符(无序关联容器不支持)|

|获取迭代器|描述|
|-|-|
|c.begin(),c.end()|返回指向c的首元素和尾元素之后位置的迭代器|
|c.cbegin(),c.cend()|返回const_iterator|

|反向容器的额外成员(不支持forward_list)|描述|
|-|-|
|reverse_iterator|按逆序寻址元素的迭代器|
|const_reverse_iterator|不能修改元素的逆序迭代器|
|c.rbegin(),c.rend()|返回指向c的尾元素和首元素之前位置的迭代器|
|c.crbegin(),c.crend()|返回const_reverse_iterator|

## 迭代器
迭代器有着公共的接口，如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的

`forward_list`迭代器不支持递减运算符(--)

## `begin`和`end`成员
当不需要写访问时，应使用`cbegin`和`cend`

## 容器定义和初始化
每个容器类型都定义一个默认构造函数，除`array`之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数
|定义和初始化|描述|
|-|-|
|C c|默认构造函数，如果c是一个`array`，则c中元素按默认方式初始化；否则c为空|
|C c1(c2) C c1=c2|c1初始化为c2的拷贝，c1和c2必须是相同类型(即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于`array`类型，两者还必须具有相同大小)|
|C c{a, b, c...} C c={a, b, c...}|c初始化为初始化列表中元素的拷贝，列表中元素的类型必须与C的元素类型相容。对于`array`类型，列表中元素数目必须等于或小于`array`的大小，任何遗漏的元素都进行值初始化)|
|C c(b, e)|c初始化为迭代器b和e指定范围中的元素的拷贝，范围中元素的类型必须与C的元素类型相容(`array`不适用)|
|C seq(n)|seq包含n个元素，这些元素进行了值初始化；次构造函数是`explicit`的(`string`不适用)|
|C seq(n, t)|seq包含n个初始化为值t的元素|

只有顺序容器(不包含`array`)的构造函数才能接受大小参数

## 赋值和`swap`
|操作|描述|
|-|-|
|c1=c2|将c1中的元素替换为c2中元素的拷贝，c1和c2必须具有相同的类型|
|c={a,b,c...}|将c1中元素替换为初始化列表中元素的拷贝(`array`不适用)|
|swap(c1,c2) c1.swap(c2)|交换c1和c2中的元素，c1和c2必须具有相同的类型，`swap`通常比从c2向c1拷贝元素快得多|
|seq.assign(b,e)|将seq中的元素替换为迭代器b和e所表示的范围中的元素，迭代器b和e不能指向seq中的元素|
|seq.assign(il)|将seq中的元素替换为初始化表il中的元素|
|seq.assign(n,t)|将seq中的元素替换为n个值为t的元素|

`assign`操作不适用于关联容器和`array`
赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而`swap`操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效

除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成

## 关系运算符
1. 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等
2. 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
3. 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果

# 顺序容器操作
## 向顺序容器添加元素
|操作|描述|
|-|-|
|c.push_back(t) c.emplace_back(args)|在c的尾部创建一个值为t或由args创建的元素，返回void|
|c.push_front(t) c.emplace_front(args)|在c的头部创建一个值为t或由args创建的元素，返回void|
|c.insert(p,t) c.emplace(p,args)|在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器|
|c.insert(p,n,t)|在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器；若n为0，则返回p|
|c.insert(p,b,e)|将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回p|
|c.insert(p,il)|il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前，返回指向新添加的第一个元素的迭代器，若列表为空，则返回p|

这些操作都会改变容器的大小，`array`不支持这些操作
`forward_list`有自己的`insert`和`emplace`
`forward_list`不支持`push_back`和`emplace_back`
`vector`和`string`不支持`push_front`和`emplace_front`
向一个`vector`、`string`和`deque`插入元素会使所有指向容器的迭代器、引用和指针失效

当用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身，容器中的元素与提供值的对象之间没有任何关联，随后对容器中元素的任何改变都不会影响到原始对象

## 访问元素
|操作|描述|
|-|-|
|c.back()|返回c中尾元素的引用，若c为空，函数行为未定义|
|c.front()|返回c中首元素的引用，若c为空，函数行为未定义|
|c[n]|返回c中下标为n的元素的引用，n是一个无符号整数，若n>=c.size()，则函数行为未定义|
|c.at(n)|返回下标为n的元素的引用，如果下标越界，则抛出一个`out_of_range`异常|

`at`和下标操作只适用于`string`、`vector`、`deque`和`array`
`back`不适用于`forward_list`

对一个空容器调用`front`和`back`，就像使用一个越界的下标一样，是一种严重的程序设计错误

### 访问成员函数返回的是引用
如果容器是一个`const`对象，则返回值是`const`引用，如果容器不是`const`的，则返回值是普通引用，允许改变元素的值

### 安全随机访问
使用`at`函数实现安全的随机访问

## 删除元素
|操作|描述|
|-|-|
|c.pop_back()|删除c中尾元素，若c为空，则函数行为未定义，函数返回void|
|c.pop_front()|删除c中首元素，若c为空，则函数行为未定义，函数返回void|
|c.erase(p)|删除迭代器p所指定的元素，返回一个指向被删元素之后的元素的迭代器，若p指向尾元素，则返回尾后(off-the-end)迭代器，若p是尾后迭代器，则函数行为未定义|
|c.erase(b, e)|删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器|
|c.clear()|删除c中所有元素，返回void|

这些操作会改变容器大小，所有不适用于`array`
`forward_list`有特殊版本的`erase`
`forward_list`不支持`pop_back`；`vector`和`string`不支持`pop_front`

删除`deque`中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效，指向`vector`或`string`中删除点之后位置的迭代器、引用和指针都会失效

## 特殊`forward_list`操作

