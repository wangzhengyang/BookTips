[toc]

# OOP概述
面对对象程序设计的核心思想是数据抽象、继承和动态绑定；通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

## 继承
通过**继承**联系在一起的类构成一种层次关系，通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类**，基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员

在C++语言汇总，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待，对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类将这些函数声明成**虚函数**

派生类必须通过使用**类派生列表**明确指出它是从哪个基类继承而来的

## 动态绑定
在C++语言中，当使用基类的引用(或指针)调用一个虚函数时将发生动态绑定

# 定义基类和派生类
## 定义基类
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

## 定义派生类
在派生类对象中含有与基类对应的组成部分，这一事实是继承的关键所在

尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员，和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分

首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

派生类可以访问基类的公有成员和受保护成员

### 继承与静态成员
如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例

静态成员遵循通用的访问控制规则，如果基类中的成员是`private`的，则派生类无权访问它，假设某静态成员是可访问的，则既能通过基类使用它也能通过派生类使用它

通过类名后面加关键字`final`，防止继承发生

## 类型转换与继承
存在继承关系的类，可以将基类的指针或引用绑定到派生类对象上，当使用基类的引用(或指针)时，实际上并不清楚该引用(或指针)所绑定对象的真实类型，该对象可能是基类的对象，也可能是派生类的对象

和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着可以将一个派生类对象的指针存储在一个基类的智能指针上

当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动和赋值，它的派生类部分将被忽略掉

# 虚函数